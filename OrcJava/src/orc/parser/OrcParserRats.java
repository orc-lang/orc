// ===========================================================================
// This file has been generated by
// Rats! Parser Generator, version 1.14.0,
// (C) 2004-2008 Robert Grimm,
// on Tuesday, August 12, 2008 at 5:58:45 PM.
// Edit at your own risk.
// ===========================================================================

package orc.parser;

import java.io.Reader;
import java.io.IOException;

import xtc.util.Pair;

import xtc.parser.ParserBase;
import xtc.parser.Column;
import xtc.parser.Result;
import xtc.parser.SemanticValue;
import xtc.parser.ParseError;

import java.util.List;
import java.util.LinkedList;
import java.util.ListIterator;
import java.io.FileNotFoundException;
import java.math.BigInteger;
import java.math.BigDecimal;
import orc.ast.extended.*;
import orc.ast.extended.declaration.*;
import orc.ast.extended.pattern.*;
import orc.error.*;
import orc.Orc;
import xtc.util.Utilities;
import xtc.util.Action;
import xtc.tree.Location;

/**
 * Packrat parser for grammar <code>orc.parser.OrcParserRats</code>.
 *
 * <p />This class has been generated by the <i>Rats!</i> parser
 * generator, version 1.14.0, (C) 2004-2008 Robert Grimm.
 */
public final class OrcParserRats extends ParserBase {

  // =========================================================================

  /** Chunk 1 of memoized results. */
  static final class Chunk1 {
    Result fBody;
    Result fDeclarations;
    Result fPatternList;
    Result fPatternList$$Star1;
    Result fMaybeWhereExpression;
    Result fMaybeWhereExpression$$Plus1;
    Result fMaybeBarExpression;
    Result fSafeMaybeBarExpression;
    Result fSeqExpression;
    Result fMaybeSeqExpression;
  }

  /** Chunk 2 of memoized results. */
  static final class Chunk2 {
    Result fSafeMaybeSeqExpression;
    Result fMaybeDisjunction;
    Result fSafeMaybeDisjunction;
    Result fMaybeConjunction;
    Result fSafeMaybeConjunction;
    Result fMaybeComparison;
    Result fSafeMaybeComparison;
    Result fComparable;
    Result fCons;
    Result fMaybeProduct;
  }

  /** Chunk 3 of memoized results. */
  static final class Chunk3 {
    Result fMaybeProduct$$Star1;
    Result fMaybeSigned;
    Result fBasicExpression;
    Result fExpressionList;
    Result fExpressionList$$Star1;
    Result fPattern;
    Result fConsPattern;
    Result fBasicPattern;
    Result fLiteral;
    Result fExponent;
  }

  /** Chunk 4 of memoized results. */
  static final class Chunk4 {
    Result fSignedIntegerToken;
    Result fIntegerToken;
    Result fIntegerToken$$Star1;
    Result fStringLiteral;
    Result fClassName;
    Result fIdentifier;
    Result fWordToken;
    Result fWordToken$$Star1;
  }

  // =========================================================================

  /** Memoization table column. */
  static final class OrcParserRatsColumn extends Column {
    Chunk1 chunk1;
    Chunk2 chunk2;
    Chunk3 chunk3;
    Chunk4 chunk4;
  }

  // =========================================================================

  /**
   * Create a new packrat parser.
   *
   * @param reader The reader.
   * @param file The file name.
   */
  public OrcParserRats(final Reader reader, final String file) {
    super(reader, file);
  }

  /**
   * Create a new packrat parser.
   *
   * @param reader The file reader.
   * @param file The file name.
   * @param size The file size.
   */
  public OrcParserRats(final Reader reader, final String file, final int size) {
    super(reader, file, size);
  }

  // =========================================================================

  protected Column newColumn() {
    return new OrcParserRatsColumn();
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.Program.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pProgram(final int yyStart) throws IOException {
    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSpace(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pBody(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        yyResult = pEndOfFile(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.Module.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pModule(final int yyStart) throws IOException {
    Result            yyResult;
    List<Declaration> yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSpace(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pDeclarations(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        yyResult = pEndOfFile(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.Body.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBody(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fBody) 
      yyColumn.chunk1.fBody = pBody$1(yyStart);
    return yyColumn.chunk1.fBody;
  }

  /** Actually parse orc.parser.OrcParserRats.Body. */
  private Result pBody$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pDeclarations(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final List<Declaration> ds = yyResult.semanticValue();

      yyResult = pGoalExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Expression g = yyResult.semanticValue();

        Expression out = g;
        ListIterator<Declaration> it = ds.listIterator(ds.size());
        while (it.hasPrevious()) {
          out = new Declare(it.previous(), out);
        }
        yyValue = out;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.Declarations.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDeclarations(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fDeclarations) 
      yyColumn.chunk1.fDeclarations = pDeclarations$1(yyStart);
    return yyColumn.chunk1.fDeclarations;
  }

  /** Actually parse orc.parser.OrcParserRats.Declarations. */
  private Result pDeclarations$1(final int yyStart) throws IOException {
    Result            yyResult;
    List<Declaration> yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pInclude(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final List<Declaration> ds = yyResult.semanticValue();

      yyResult = pDeclarations(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final List<Declaration> ds2 = yyResult.semanticValue();

        ds.addAll(ds2);
        yyValue = ds;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pDeclaration(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Declaration d = yyResult.semanticValue();

      yyResult = pDeclarations(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final List<Declaration> ds = yyResult.semanticValue();

        ds.add(0, d);
        yyValue = ds;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 3.

    yyValue = new LinkedList<Declaration>();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.Include.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pInclude(final int yyStart) throws IOException {
    Result            yyResult;
    int               yyBase;
    List<Declaration> yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pINCLUDE(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pStringLiteral(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final String filename = yyResult.semanticValue();

        yyBase = yyResult.index;

        try {
          OrcParserRats parser = new OrcParserRats(Orc.openInclude(filename), filename);
          Result result = parser.pDeclarations(0);
          if (result.hasValue()) {
            yyResult = new SemanticValue(result.semanticValue(), yyBase);
          } else {
            yyResult = new ParseError(result.parseError().msg, yyBase);
          }
        } catch (FileNotFoundException e) {
          yyResult = new ParseError("File not found: " + filename, yyBase);
        }

        yyError = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();
          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.Declaration.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDeclaration(final int yyStart) throws IOException {
    Result           yyResult;
    int              yyRepetition1;
    boolean          yyRepeated1;
    Pair<Definition> yyRepValue1;
    Declaration      yyValue;
    ParseError       yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSITE(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pDeclaration$$Choice1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final String name = yyResult.semanticValue();

        yyResult = pEQ(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pClassName(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final String className = yyResult.semanticValue();

            yyValue = new SiteDeclaration(name, className);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Alternative 2.

    yyResult = pCLASS(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pIdentifier(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final String name = yyResult.semanticValue();

        yyResult = pEQ(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pClassName(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final String className = yyResult.semanticValue();

            yyValue = new ClassDeclaration(name, className);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Alternative 3.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pDefinition(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Definition v$el$3 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepeated1   = true;
        yyRepValue1   = new Pair<Definition>(v$el$3, yyRepValue1);
        continue;
      }
      break;
    }

    if (yyRepeated1) {
      final Pair<Definition> defs = yyRepValue1.reverse();

      // a block of definitions is treated as a single
      // declaration (akin to a letrec)
      yyValue = new DefsDeclaration(defs.list());

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Alternative 4.

    yyResult = pVAL(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pPattern(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Pattern p = yyResult.semanticValue();

        yyResult = pEQ(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pBody(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Expression e = yyResult.semanticValue();

            yyValue = new ValDeclaration(p, e);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * orc.parser.OrcParserRats.Declaration$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDeclaration$$Choice1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdentifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pStringLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.Definition.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDefinition(final int yyStart) throws IOException {
    Result              yyResult;
    int                 yyRepetition1;
    Pair<List<Pattern>> yyRepValue1;
    Definition          yyValue;
    ParseError          yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pDEF(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pIdentifier(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final String name = yyResult.semanticValue();

        yyResult = pLPAREN(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pPatternList(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final List<Pattern> formals = yyResult.semanticValue();

            yyResult = pRPAREN(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyRepetition1 = yyResult.index;
              yyRepValue1   = Pair.empty();
              while (true) {

                yyResult = p$$Shared1(yyRepetition1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  final List<Pattern> v$el$1 = yyResult.semanticValue();

                  yyRepetition1 = yyResult.index;
                  yyRepValue1   = 
                    new Pair<List<Pattern>>(v$el$1, yyRepValue1);
                  continue;
                }
                break;
              }
              { // Start scope for curried0.
                final Pair<List<Pattern>> curried0 = yyRepValue1.reverse();

                yyResult = pEQ(yyRepetition1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pBody(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    final Expression body0 = yyResult.semanticValue();

                    List<List<Pattern>> curried = curried0.list();
                    ListIterator<List<Pattern>> it = curried.listIterator(curried.size());
                    Expression body = body0;
                    while (it.hasPrevious()) {
                      body = new Lambda(it.previous(), body);
                    }
                    yyValue = new Definition(name, formals, body);

                    return yyResult.createValue(yyValue, yyError);
                  }
                }
              } // End scope for curried0.
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal orc.parser.OrcParserRats.$$Shared1.
   * This nonterminal represents the duplicate productions 
   * orc.parser.OrcParserRats.Definition$$Choice1 
   * and orc.parser.OrcParserRats.Lambda$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared1(final int yyStart) throws IOException {
    Result        yyResult;
    List<Pattern> yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLPAREN(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pPatternList(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        yyResult = pRPAREN(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.PatternList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPatternList(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fPatternList) 
      yyColumn.chunk1.fPatternList = pPatternList$1(yyStart);
    return yyColumn.chunk1.fPatternList;
  }

  /** Actually parse orc.parser.OrcParserRats.PatternList. */
  private Result pPatternList$1(final int yyStart) throws IOException {
    Result        yyResult;
    List<Pattern> yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pPattern(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Pattern f = yyResult.semanticValue();

      yyResult = pPatternList$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Pair<Pattern> fs = yyResult.semanticValue();

        List<Pattern> out = fs.list();
        out.add(0, f);
        yyValue = out;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = new LinkedList<Pattern>();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal orc.parser.OrcParserRats.PatternList$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPatternList$$Star1(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fPatternList$$Star1) 
      yyColumn.chunk1.fPatternList$$Star1 = pPatternList$$Star1$1(yyStart);
    return yyColumn.chunk1.fPatternList$$Star1;
  }

  /** Actually parse orc.parser.OrcParserRats.PatternList$$Star1. */
  private Result pPatternList$$Star1$1(final int yyStart) throws IOException {
    Result        yyResult;
    Pair<Pattern> yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCOMMA(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pPattern(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Pattern fs = yyResult.semanticValue();

        yyResult = pPatternList$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Pair<Pattern> v$1 = yyResult.semanticValue();

          yyValue = new Pair<Pattern>(fs, v$1);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.GoalExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pGoalExpression(final int yyStart) throws IOException {
    Result                   yyResult;
    int                      yyRepetition1;
    Pair<Action<Expression>> yyRepValue1;
    Expression               yyValue;
    ParseError               yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLambda(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pMaybeWhereExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Expression seed = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pSemiExpressionTail(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Action<Expression> v$el$2 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Expression>>(v$el$2, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for actions.
        final Pair<Action<Expression>> actions = yyRepValue1.reverse();

        yyValue = apply(actions, seed);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for actions.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.SemiExpressionTail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSemiExpressionTail(final int yyStart) throws IOException {
    Result             yyResult;
    Action<Expression> yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSEMICOLON(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pMaybeWhereExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Expression right = yyResult.semanticValue();

        yyValue = new Action<Expression>() {
          public Expression run(Expression left) {
            return new Semi(left, right);
          }
        };

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.Lambda.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLambda(final int yyStart) throws IOException {
    Result              yyResult;
    int                 yyRepetition1;
    Pair<List<Pattern>> yyRepValue1;
    Expression          yyValue;
    ParseError          yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLAMBDA(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pLPAREN(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pPatternList(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final List<Pattern> formals = yyResult.semanticValue();

          yyResult = pRPAREN(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyRepetition1 = yyResult.index;
            yyRepValue1   = Pair.empty();
            while (true) {

              yyResult = p$$Shared1(yyRepetition1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                final List<Pattern> v$el$1 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepValue1   = new Pair<List<Pattern>>(v$el$1, yyRepValue1);
                continue;
              }
              break;
            }
            { // Start scope for curried0.
              final Pair<List<Pattern>> curried0 = yyRepValue1.reverse();

              yyResult = pEQ(yyRepetition1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pBody(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  final Expression body0 = yyResult.semanticValue();

                  List<List<Pattern>> curried = curried0.list();
                  ListIterator<List<Pattern>> it = curried.listIterator(curried.size());
                  Expression body = body0;
                  while (it.hasPrevious()) {
                    body = new Lambda(it.previous(), body);
                  }
                  yyValue = new Lambda(formals, body);

                  return yyResult.createValue(yyValue, yyError);
                }
              }
            } // End scope for curried0.
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.MaybeWhereExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMaybeWhereExpression(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fMaybeWhereExpression) 
      yyColumn.chunk1.fMaybeWhereExpression = pMaybeWhereExpression$1(yyStart);
    return yyColumn.chunk1.fMaybeWhereExpression;
  }

  /** Actually parse orc.parser.OrcParserRats.MaybeWhereExpression. */
  private Result pMaybeWhereExpression$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSafeMaybeBarExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Expression seed = yyResult.semanticValue();

      yyResult = pMaybeWhereExpression$$Plus1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Pair<Action<Expression>> actions = yyResult.semanticValue();

        yyValue = apply(actions, seed);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pMaybeBarExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * orc.parser.OrcParserRats.MaybeWhereExpression$$Plus1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMaybeWhereExpression$$Plus1(final int yyStart) 
    throws IOException {

    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fMaybeWhereExpression$$Plus1) 
      yyColumn.chunk1.fMaybeWhereExpression$$Plus1 = pMaybeWhereExpression$$Plus1$1(yyStart);
    return yyColumn.chunk1.fMaybeWhereExpression$$Plus1;
  }

  /** Actually parse orc.parser.OrcParserRats.MaybeWhereExpression$$Plus1. */
  private Result pMaybeWhereExpression$$Plus1$1(final int yyStart) 
    throws IOException {

    Result                   yyResult;
    Pair<Action<Expression>> yyValue;
    ParseError               yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWhereExpressionTail(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Action<Expression> v$el$2 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pMaybeWhereExpression$$Plus1(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Pair<Action<Expression>> v$3 = yyResult.semanticValue();

        yyValue = new Pair<Action<Expression>>(v$el$2, v$3);

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyValue = new Pair<Action<Expression>>(v$el$2);

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.WhereExpressionTail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pWhereExpressionTail(final int yyStart) throws IOException {
    Result             yyResult;
    int                yyOption1;
    Pattern            yyOpValue1;
    Action<Expression> yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLANGLE(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pPattern(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Pattern v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for p.
        final Pattern p = yyOpValue1;

        yyResult = pLANGLE(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pSafeMaybeBarExpression(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Expression right = yyResult.semanticValue();

            yyValue = new Action<Expression>() {
              public Expression run(Expression left) {
                if (p == null) return new Where(left, right);
                else return new Where(left, right, p);
              }
            };

            return yyResult.createValue(yyValue, yyError);
          }
        }
      } // End scope for p.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.MaybeBarExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMaybeBarExpression(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fMaybeBarExpression) 
      yyColumn.chunk1.fMaybeBarExpression = pMaybeBarExpression$1(yyStart);
    return yyColumn.chunk1.fMaybeBarExpression;
  }

  /** Actually parse orc.parser.OrcParserRats.MaybeBarExpression. */
  private Result pMaybeBarExpression$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pMaybeSeqExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Expression left = yyResult.semanticValue();

      yyResult = pBAR(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pMaybeBarExpression(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Expression right = yyResult.semanticValue();

          yyValue = new Parallel(left, right);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = pMaybeSeqExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.SafeMaybeBarExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSafeMaybeBarExpression(final int yyStart) 
    throws IOException {

    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fSafeMaybeBarExpression) 
      yyColumn.chunk1.fSafeMaybeBarExpression = pSafeMaybeBarExpression$1(yyStart);
    return yyColumn.chunk1.fSafeMaybeBarExpression;
  }

  /** Actually parse orc.parser.OrcParserRats.SafeMaybeBarExpression. */
  private Result pSafeMaybeBarExpression$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSafeMaybeSeqExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Expression left = yyResult.semanticValue();

      yyResult = pBAR(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pSafeMaybeBarExpression(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Expression right = yyResult.semanticValue();

          yyValue = new Parallel(left, right);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = pSafeMaybeSeqExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.SeqExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSeqExpression(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fSeqExpression) 
      yyColumn.chunk1.fSeqExpression = pSeqExpression$1(yyStart);
    return yyColumn.chunk1.fSeqExpression;
  }

  /** Actually parse orc.parser.OrcParserRats.SeqExpression. */
  private Result pSeqExpression$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Pattern    yyOpValue1;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSafeMaybeDisjunction(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Expression left = yyResult.semanticValue();

      yyResult = pRANGLE(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pPattern(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Pattern v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
        { // Start scope for p.
          final Pattern p = yyOpValue1;

          yyResult = pRANGLE(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pSafeMaybeSeqExpression(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Expression right = yyResult.semanticValue();

              if (p == null) yyValue = new Sequential(left, right);
              else yyValue = new Sequential(left, right, p);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        } // End scope for p.
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.MaybeSeqExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMaybeSeqExpression(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fMaybeSeqExpression) 
      yyColumn.chunk1.fMaybeSeqExpression = pMaybeSeqExpression$1(yyStart);
    return yyColumn.chunk1.fMaybeSeqExpression;
  }

  /** Actually parse orc.parser.OrcParserRats.MaybeSeqExpression. */
  private Result pMaybeSeqExpression$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSeqExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pMaybeDisjunction(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.SafeMaybeSeqExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSafeMaybeSeqExpression(final int yyStart) 
    throws IOException {

    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fSafeMaybeSeqExpression) 
      yyColumn.chunk2.fSafeMaybeSeqExpression = pSafeMaybeSeqExpression$1(yyStart);
    return yyColumn.chunk2.fSafeMaybeSeqExpression;
  }

  /** Actually parse orc.parser.OrcParserRats.SafeMaybeSeqExpression. */
  private Result pSafeMaybeSeqExpression$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSeqExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pSafeMaybeDisjunction(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.MaybeDisjunction.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMaybeDisjunction(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fMaybeDisjunction) 
      yyColumn.chunk2.fMaybeDisjunction = pMaybeDisjunction$1(yyStart);
    return yyColumn.chunk2.fMaybeDisjunction;
  }

  /** Actually parse orc.parser.OrcParserRats.MaybeDisjunction. */
  private Result pMaybeDisjunction$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pMaybeConjunction(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Expression left = yyResult.semanticValue();

      yyResult = pOROR(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final int index = yyResult.semanticValue();

        yyResult = pMaybeDisjunction(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Expression right = yyResult.semanticValue();

          yyValue = at(index, new Call("op||", left, right));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = pMaybeConjunction(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.SafeMaybeDisjunction.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSafeMaybeDisjunction(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fSafeMaybeDisjunction) 
      yyColumn.chunk2.fSafeMaybeDisjunction = pSafeMaybeDisjunction$1(yyStart);
    return yyColumn.chunk2.fSafeMaybeDisjunction;
  }

  /** Actually parse orc.parser.OrcParserRats.SafeMaybeDisjunction. */
  private Result pSafeMaybeDisjunction$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSafeMaybeConjunction(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Expression left = yyResult.semanticValue();

      yyResult = pOROR(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final int index = yyResult.semanticValue();

        yyResult = pSafeMaybeDisjunction(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Expression right = yyResult.semanticValue();

          yyValue = at(index, new Call("op||", left, right));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = pSafeMaybeConjunction(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.MaybeConjunction.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMaybeConjunction(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fMaybeConjunction) 
      yyColumn.chunk2.fMaybeConjunction = pMaybeConjunction$1(yyStart);
    return yyColumn.chunk2.fMaybeConjunction;
  }

  /** Actually parse orc.parser.OrcParserRats.MaybeConjunction. */
  private Result pMaybeConjunction$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pMaybeComparison(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Expression left = yyResult.semanticValue();

      yyResult = pANDAND(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final int index = yyResult.semanticValue();

        yyResult = pMaybeConjunction(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Expression right = yyResult.semanticValue();

          yyValue = at(index, new Call("op&&", left, right));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = pMaybeComparison(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.SafeMaybeConjunction.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSafeMaybeConjunction(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fSafeMaybeConjunction) 
      yyColumn.chunk2.fSafeMaybeConjunction = pSafeMaybeConjunction$1(yyStart);
    return yyColumn.chunk2.fSafeMaybeConjunction;
  }

  /** Actually parse orc.parser.OrcParserRats.SafeMaybeConjunction. */
  private Result pSafeMaybeConjunction$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSafeMaybeComparison(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Expression left = yyResult.semanticValue();

      yyResult = pANDAND(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final int index = yyResult.semanticValue();

        yyResult = pSafeMaybeConjunction(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Expression right = yyResult.semanticValue();

          yyValue = at(index, new Call("op&&", left, right));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = pSafeMaybeComparison(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.MaybeComparison.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMaybeComparison(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fMaybeComparison) 
      yyColumn.chunk2.fMaybeComparison = pMaybeComparison$1(yyStart);
    return yyColumn.chunk2.fMaybeComparison;
  }

  /** Actually parse orc.parser.OrcParserRats.MaybeComparison. */
  private Result pMaybeComparison$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pComparable(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Expression left = yyResult.semanticValue();

      yyResult = pComparator(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Indexed<String> op = yyResult.semanticValue();

        yyResult = pComparable(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Expression right = yyResult.semanticValue();

          yyValue = at(op.index, new Call(op.value, left, right));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = pSafeMaybeComparison(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.Comparator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pComparator(final int yyStart) throws IOException {
    Result          yyResult;
    Indexed<String> yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pComparator$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Object value = yyResult.semanticValue();

      yyValue = new Indexed(value, yyStart);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal orc.parser.OrcParserRats.Comparator$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pComparator$$Choice1(final int yyStart) throws IOException {
    Result     yyResult;
    Object     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pRANGLE(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = "op>";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pLANGLE(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = "op<";

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.SafeMaybeComparison.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSafeMaybeComparison(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fSafeMaybeComparison) 
      yyColumn.chunk2.fSafeMaybeComparison = pSafeMaybeComparison$1(yyStart);
    return yyColumn.chunk2.fSafeMaybeComparison;
  }

  /** Actually parse orc.parser.OrcParserRats.SafeMaybeComparison. */
  private Result pSafeMaybeComparison$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pComparable(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Expression left = yyResult.semanticValue();

      yyResult = pSafeComparator(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Indexed<String> op = yyResult.semanticValue();

        yyResult = pComparable(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Expression right = yyResult.semanticValue();

          yyValue = at(op.index, new Call(op.value, left, right));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = pComparable(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.SafeComparator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSafeComparator(final int yyStart) throws IOException {
    Result          yyResult;
    Indexed<String> yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSafeComparator$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Object value = yyResult.semanticValue();

      yyValue = new Indexed(value, yyStart);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * orc.parser.OrcParserRats.SafeComparator$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSafeComparator$$Choice1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Object     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pEQ(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = "op=";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pNEQ(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = "op/=";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pGT(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = "op>";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pGEQ(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = "op>=";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = pLT(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = "op<";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 6.

    yyResult = pLEQ(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = "op<=";

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.Comparable.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pComparable(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fComparable) 
      yyColumn.chunk2.fComparable = pComparable$1(yyStart);
    return yyColumn.chunk2.fComparable;
  }

  /** Actually parse orc.parser.OrcParserRats.Comparable. */
  private Result pComparable$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNOT(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pBasicExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Expression x = yyResult.semanticValue();

        yyValue = at(yyStart, new Call("op~", x));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pCons(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pMaybeSum(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.Cons.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCons(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fCons) 
      yyColumn.chunk2.fCons = pCons$1(yyStart);
    return yyColumn.chunk2.fCons;
  }

  /** Actually parse orc.parser.OrcParserRats.Cons. */
  private Result pCons$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pMaybeSigned(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Expression left = yyResult.semanticValue();

      yyResult = pCOLON(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final int index = yyResult.semanticValue();

        yyResult = pMaybeCons(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Expression right = yyResult.semanticValue();

          yyValue = at(index, new ConsExpr(left, right));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.MaybeCons.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMaybeCons(final int yyStart) throws IOException {
    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCons(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pMaybeSigned(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.MaybeSum.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMaybeSum(final int yyStart) throws IOException {
    Result                   yyResult;
    int                      yyRepetition1;
    Pair<Action<Expression>> yyRepValue1;
    Expression               yyValue;
    ParseError               yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pMaybeProduct(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Expression seed = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pSumTail(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Action<Expression> v$el$1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Expression>>(v$el$1, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for actions.
        final Pair<Action<Expression>> actions = yyRepValue1.reverse();

        yyValue = apply(actions, seed);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for actions.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.SumTail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSumTail(final int yyStart) throws IOException {
    Result             yyResult;
    Action<Expression> yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSumOperator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Indexed<String> op = yyResult.semanticValue();

      yyResult = pMaybeProduct(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Expression right = yyResult.semanticValue();

        yyValue = new Action<Expression>() {
          public Expression run(Expression left) {
            return at(op.index, new Call(op.value, left, right));
          }
        };

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.SumOperator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSumOperator(final int yyStart) throws IOException {
    Result          yyResult;
    Indexed<String> yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSumOperator$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Object value = yyResult.semanticValue();

      yyValue = new Indexed(value, yyStart);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * orc.parser.OrcParserRats.SumOperator$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSumOperator$$Choice1(final int yyStart) throws IOException {
    Result     yyResult;
    Object     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pPLUS(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = "op+";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pMINUS(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = "op-";

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.MaybeProduct.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMaybeProduct(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fMaybeProduct) 
      yyColumn.chunk2.fMaybeProduct = pMaybeProduct$1(yyStart);
    return yyColumn.chunk2.fMaybeProduct;
  }

  /** Actually parse orc.parser.OrcParserRats.MaybeProduct. */
  private Result pMaybeProduct$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pMaybeSigned(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Expression seed = yyResult.semanticValue();

      yyResult = pMaybeProduct$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Pair<Action<Expression>> actions = yyResult.semanticValue();

        yyValue = apply(actions, seed);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal orc.parser.OrcParserRats.MaybeProduct$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMaybeProduct$$Star1(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fMaybeProduct$$Star1) 
      yyColumn.chunk3.fMaybeProduct$$Star1 = pMaybeProduct$$Star1$1(yyStart);
    return yyColumn.chunk3.fMaybeProduct$$Star1;
  }

  /** Actually parse orc.parser.OrcParserRats.MaybeProduct$$Star1. */
  private Result pMaybeProduct$$Star1$1(final int yyStart) 
    throws IOException {

    Result                   yyResult;
    Pair<Action<Expression>> yyValue;
    ParseError               yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pProductTail(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Action<Expression> v$el$1 = yyResult.semanticValue();

      yyResult = pMaybeProduct$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Pair<Action<Expression>> v$2 = yyResult.semanticValue();

        yyValue = new Pair<Action<Expression>>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.ProductTail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pProductTail(final int yyStart) throws IOException {
    Result             yyResult;
    Action<Expression> yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pProductOperator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Indexed<String> op = yyResult.semanticValue();

      yyResult = pMaybeSigned(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Expression right = yyResult.semanticValue();

        yyValue = new Action<Expression>() {
          public Expression run(Expression left) {
            return at(op.index, new Call(op.value, left, right));
          }
        };

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.ProductOperator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pProductOperator(final int yyStart) throws IOException {
    Result          yyResult;
    Indexed<String> yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pProductOperator$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Object value = yyResult.semanticValue();

      yyValue = new Indexed(value, yyStart);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * orc.parser.OrcParserRats.ProductOperator$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pProductOperator$$Choice1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Object     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pDIV(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = "op/";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pMOD(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = "op%";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pTIMES(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = "op*";

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.MaybeSigned.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMaybeSigned(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fMaybeSigned) 
      yyColumn.chunk3.fMaybeSigned = pMaybeSigned$1(yyStart);
    return yyColumn.chunk3.fMaybeSigned;
  }

  /** Actually parse orc.parser.OrcParserRats.MaybeSigned. */
  private Result pMaybeSigned$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pMINUS(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pBasicExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Expression x = yyResult.semanticValue();

        yyValue = at(yyStart, new Call("opu-", x));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pBasicExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.BasicExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBasicExpression(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fBasicExpression) 
      yyColumn.chunk3.fBasicExpression = pBasicExpression$1(yyStart);
    return yyColumn.chunk3.fBasicExpression;
  }

  /** Actually parse orc.parser.OrcParserRats.BasicExpression. */
  private Result pBasicExpression$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pSTOP(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = new Silent();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pNULL(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      // We're changing "null" to "stop" but
      // for now we're still allowing both
      yyValue = new Silent();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pCall(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = pLPAREN(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pExpressionList(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final List<Expression> args = yyResult.semanticValue();

        yyResult = pRPAREN(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          if (args.size() == 1) {
            yyValue = args.get(0);
          } else {
            yyValue = at(yyStart, new Let(args));
          }

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 6.

    yyResult = pLBRACKET(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pExpressionList(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final List<Expression> args = yyResult.semanticValue();

        yyResult = pRBRACKET(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = at(yyStart, new ListExpr(args));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.Call.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCall(final int yyStart) throws IOException {
    Result                   yyResult;
    int                      yyRepetition1;
    Pair<Action<Expression>> yyRepValue1;
    Expression               yyValue;
    ParseError               yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdentifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String seed = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pCallTail(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Action<Expression> v$el$1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Expression>>(v$el$1, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for actions.
        final Pair<Action<Expression>> actions = yyRepValue1.reverse();

        yyValue = apply(actions, at(yyStart, new Name(seed)));

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for actions.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.CallTail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCallTail(final int yyStart) throws IOException {
    Result             yyResult;
    Action<Expression> yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pDOT(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pIdentifier(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final String right = yyResult.semanticValue();

        yyValue = new Action<Expression>() {
          public Expression run(Expression left) {
            return at(yyStart, new Dot(left, right));
          }
        };

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pLPAREN(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pExpressionList(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final List<Expression> args = yyResult.semanticValue();

        yyResult = pRPAREN(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = new Action<Expression>() {
            public Expression run(Expression left) {
              return at(yyStart, new Call(left, args));
            }
          };

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.ExpressionList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpressionList(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fExpressionList) 
      yyColumn.chunk3.fExpressionList = pExpressionList$1(yyStart);
    return yyColumn.chunk3.fExpressionList;
  }

  /** Actually parse orc.parser.OrcParserRats.ExpressionList. */
  private Result pExpressionList$1(final int yyStart) throws IOException {
    Result           yyResult;
    List<Expression> yyValue;
    ParseError       yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBody(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Expression f = yyResult.semanticValue();

      yyResult = pExpressionList$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Pair<Expression> fs = yyResult.semanticValue();

        List<Expression> out = fs.list();
        out.add(0, f);
        yyValue = out;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = new LinkedList<Expression>();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * orc.parser.OrcParserRats.ExpressionList$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpressionList$$Choice1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Expression yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCOMMA(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pBody(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * orc.parser.OrcParserRats.ExpressionList$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpressionList$$Star1(final int yyStart) 
    throws IOException {

    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fExpressionList$$Star1) 
      yyColumn.chunk3.fExpressionList$$Star1 = pExpressionList$$Star1$1(yyStart);
    return yyColumn.chunk3.fExpressionList$$Star1;
  }

  /** Actually parse orc.parser.OrcParserRats.ExpressionList$$Star1. */
  private Result pExpressionList$$Star1$1(final int yyStart) 
    throws IOException {

    Result           yyResult;
    Pair<Expression> yyValue;
    ParseError       yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExpressionList$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Expression v$el$1 = yyResult.semanticValue();

      yyResult = pExpressionList$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Pair<Expression> v$2 = yyResult.semanticValue();

        yyValue = new Pair<Expression>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.Pattern.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPattern(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fPattern) 
      yyColumn.chunk3.fPattern = pPattern$1(yyStart);
    return yyColumn.chunk3.fPattern;
  }

  /** Actually parse orc.parser.OrcParserRats.Pattern. */
  private Result pPattern$1(final int yyStart) throws IOException {
    Result     yyResult;
    Pattern    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pConsPattern(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Pattern p = yyResult.semanticValue();

      yyResult = pAS(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final int index = yyResult.semanticValue();

        yyResult = pIdentifier(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final String v = yyResult.semanticValue();

          yyValue = at(index, new AsPattern(p, v));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = pConsPattern(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.ConsPattern.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pConsPattern(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fConsPattern) 
      yyColumn.chunk3.fConsPattern = pConsPattern$1(yyStart);
    return yyColumn.chunk3.fConsPattern;
  }

  /** Actually parse orc.parser.OrcParserRats.ConsPattern. */
  private Result pConsPattern$1(final int yyStart) throws IOException {
    Result     yyResult;
    Pattern    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBasicPattern(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Pattern left = yyResult.semanticValue();

      yyResult = pCOLON(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final int index = yyResult.semanticValue();

        yyResult = pConsPattern(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Pattern right = yyResult.semanticValue();

          yyValue = at(index, new ConsPattern(left, right));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = pBasicPattern(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.BasicPattern.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBasicPattern(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fBasicPattern) 
      yyColumn.chunk3.fBasicPattern = pBasicPattern$1(yyStart);
    return yyColumn.chunk3.fBasicPattern;
  }

  /** Actually parse orc.parser.OrcParserRats.BasicPattern. */
  private Result pBasicPattern$1(final int yyStart) throws IOException {
    Result     yyResult;
    Pattern    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pUNDERSCORE(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = new WildcardPattern();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Literal literal = yyResult.semanticValue();

      yyValue = new LiteralPattern(literal);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pIdentifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String name = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pLPAREN(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final int index = yyResult.semanticValue();

        yyResult = pPatternList(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final List<Pattern> formals = yyResult.semanticValue();

          yyResult = pRPAREN(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = at(index, new CallPattern(name, new TuplePattern(formals)));

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }

      // Nested alternative 2.

      yyValue = at(yyStart, new VariablePattern(name));

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Alternative 4.

    yyResult = pBANG(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pBasicPattern(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Pattern p = yyResult.semanticValue();

        yyValue = new PublishPattern(p);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 5.

    yyResult = pLPAREN(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pPatternList(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final List<Pattern> formals = yyResult.semanticValue();

        yyResult = pRPAREN(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = at(yyStart, new TuplePattern(formals));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 6.

    yyResult = pLBRACKET(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pPatternList(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final List<Pattern> formals = yyResult.semanticValue();

        yyResult = pRBRACKET(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = at(yyStart, new ListPattern(formals));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.Literal.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLiteral(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fLiteral) 
      yyColumn.chunk3.fLiteral = pLiteral$1(yyStart);
    return yyColumn.chunk3.fLiteral;
  }

  /** Actually parse orc.parser.OrcParserRats.Literal. */
  private Result pLiteral$1(final int yyStart) throws IOException {
    Result     yyResult;
    Literal    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLiteral$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Object literal = yyResult.semanticValue();

      yyValue = new Literal(literal);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal orc.parser.OrcParserRats.Literal$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLiteral$$Choice1(final int yyStart) throws IOException {
    Result     yyResult;
    Object     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNumber(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pStringLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pTRUE(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = true;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pFALSE(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = false;

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.Number.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNumber(final int yyStart) throws IOException {
    Result     yyResult;
    Number     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pFloat(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pInteger(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.Float.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFloat(final int yyStart) throws IOException {
    Result     yyResult;
    BigDecimal yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pFloatToken(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String rep = yyResult.semanticValue();

      yyResult = pSpace(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        try {
          yyValue = BigDecimal.valueOf(Double.parseDouble(rep));
        } catch (NumberFormatException e) {
          // impossible by construction
          throw new AssertionError(e);
        }

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.FloatToken.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFloatToken(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyRepetition1;
    boolean    yyRepeated1;
    int        yyOption1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSignedIntegerToken(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyC = character(yyChoice1);
      if ('.' == yyC) {
        yyIndex = yyChoice1 + 1;

        yyRepetition1 = yyIndex;
        yyRepeated1   = false;
        while (true) {

          yyC = character(yyRepetition1);
          if (-1 != yyC) {
            yyIndex = yyRepetition1 + 1;

            switch (yyC) {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
              {
                yyRepetition1 = yyIndex;
                yyRepeated1   = true;
                continue;
              }

            default:
              /* No match. */
            }
          }
          break;
        }

        if (yyRepeated1) {

          yyOption1  = yyRepetition1;

          yyResult = pExponent(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyOption1  = yyResult.index;
          }

          yyValue = difference(yyStart, yyOption1);

          return new SemanticValue(yyValue, yyOption1, yyError);
        }
      }

      // Nested alternative 2.

      yyResult = pExponent(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = difference(yyStart, yyResult.index);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("float token expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.Exponent.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExponent(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fExponent) 
      yyColumn.chunk3.fExponent = pExponent$1(yyStart);
    return yyColumn.chunk3.fExponent;
  }

  /** Actually parse orc.parser.OrcParserRats.Exponent. */
  private Result pExponent$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyOption1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case 'E':
      case 'e':
        {
          yyOption1  = yyIndex;

          yyC = character(yyOption1);
          if (-1 != yyC) {
            yyIndex = yyOption1 + 1;

            switch (yyC) {
            case '+':
            case '-':
              {
                yyOption1  = yyIndex;
              }

            default:
              /* No match. */
            }
          }

          yyResult = pIntegerToken(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = null;

            return yyResult.createValue(yyValue, yyError);
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("exponent expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.Integer.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pInteger(final int yyStart) throws IOException {
    Result     yyResult;
    BigInteger yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSignedIntegerToken(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String rep = yyResult.semanticValue();

      yyResult = pSpace(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        try {
          yyValue = BigInteger.valueOf(Long.parseLong(rep));
        } catch (NumberFormatException e) {
          // impossible by construction
          throw new AssertionError(e);
        }

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.SignedIntegerToken.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSignedIntegerToken(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fSignedIntegerToken) 
      yyColumn.chunk4.fSignedIntegerToken = pSignedIntegerToken$1(yyStart);
    return yyColumn.chunk4.fSignedIntegerToken;
  }

  /** Actually parse orc.parser.OrcParserRats.SignedIntegerToken. */
  private Result pSignedIntegerToken$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyOption1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;

    yyC = character(yyOption1);
    if ('-' == yyC) {
      yyIndex = yyOption1 + 1;

      yyOption1  = yyIndex;
    }

    yyResult = pIntegerToken(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = difference(yyStart, yyResult.index);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("signed integer token expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.IntegerToken.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIntegerToken(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fIntegerToken) 
      yyColumn.chunk4.fIntegerToken = pIntegerToken$1(yyStart);
    return yyColumn.chunk4.fIntegerToken;
  }

  /** Actually parse orc.parser.OrcParserRats.IntegerToken. */
  private Result pIntegerToken$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '0':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        {
          yyResult = pIntegerToken$$Star1(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = null;

            return yyResult.createValue(yyValue, yyError);
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("integer token expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal orc.parser.OrcParserRats.IntegerToken$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIntegerToken$$Star1(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fIntegerToken$$Star1) 
      yyColumn.chunk4.fIntegerToken$$Star1 = pIntegerToken$$Star1$1(yyStart);
    return yyColumn.chunk4.fIntegerToken$$Star1;
  }

  /** Actually parse orc.parser.OrcParserRats.IntegerToken$$Star1. */
  private Result pIntegerToken$$Star1$1(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        {
          yyResult = pIntegerToken$$Star1(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = null;

            return yyResult.createValue(yyValue, yyError);
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Alternative 2.

    yyValue = null;

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.StringLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStringLiteral(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fStringLiteral) 
      yyColumn.chunk4.fStringLiteral = pStringLiteral$1(yyStart);
    return yyColumn.chunk4.fStringLiteral;
  }

  /** Actually parse orc.parser.OrcParserRats.StringLiteral. */
  private Result pStringLiteral$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pStringLiteralToken(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String string = yyResult.semanticValue();

      yyResult = pSpace(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = Utilities.unescape(string.substring(1, string.length()-1));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.StringLiteralToken.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStringLiteralToken(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('\"' == yyC) {
      yyIndex = yyStart + 1;

      yyRepetition1 = yyIndex;
      while (true) {

        final int yyChoice1 = yyRepetition1;

        // Nested alternative 1.

        yyC = character(yyChoice1);
        if (-1 != yyC) {
          yyIndex = yyChoice1 + 1;

          switch (yyC) {
          case '\\':
            {
              final int yyChoice2 = yyIndex;

              // Nested alternative 1.

              yyC = character(yyChoice2);
              if (-1 != yyC) {
                yyIndex = yyChoice2 + 1;

                switch (yyC) {
                case '\"':
                case '\'':
                case '-':
                case '[':
                case '\\':
                case ']':
                case 'b':
                case 'f':
                case 'n':
                case 'r':
                case 't':
                  {
                    yyRepetition1 = yyIndex;
                    continue;
                  }

                case 'u':
                  {
                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;

                      switch (yyC) {
                      case '0':
                      case '1':
                      case '2':
                      case '3':
                      case '4':
                      case '5':
                      case '6':
                      case '7':
                      case '8':
                      case '9':
                      case 'A':
                      case 'B':
                      case 'C':
                      case 'D':
                      case 'E':
                      case 'F':
                      case 'a':
                      case 'b':
                      case 'c':
                      case 'd':
                      case 'e':
                      case 'f':
                        {
                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;

                            switch (yyC) {
                            case '0':
                            case '1':
                            case '2':
                            case '3':
                            case '4':
                            case '5':
                            case '6':
                            case '7':
                            case '8':
                            case '9':
                            case 'A':
                            case 'B':
                            case 'C':
                            case 'D':
                            case 'E':
                            case 'F':
                            case 'a':
                            case 'b':
                            case 'c':
                            case 'd':
                            case 'e':
                            case 'f':
                              {
                                yyC = character(yyIndex);
                                if (-1 != yyC) {
                                  yyIndex = yyIndex + 1;

                                  switch (yyC) {
                                  case '0':
                                  case '1':
                                  case '2':
                                  case '3':
                                  case '4':
                                  case '5':
                                  case '6':
                                  case '7':
                                  case '8':
                                  case '9':
                                  case 'A':
                                  case 'B':
                                  case 'C':
                                  case 'D':
                                  case 'E':
                                  case 'F':
                                  case 'a':
                                  case 'b':
                                  case 'c':
                                  case 'd':
                                  case 'e':
                                  case 'f':
                                    {
                                      yyC = character(yyIndex);
                                      if (-1 != yyC) {
                                        yyIndex = yyIndex + 1;

                                        switch (yyC) {
                                        case '0':
                                        case '1':
                                        case '2':
                                        case '3':
                                        case '4':
                                        case '5':
                                        case '6':
                                        case '7':
                                        case '8':
                                        case '9':
                                        case 'A':
                                        case 'B':
                                        case 'C':
                                        case 'D':
                                        case 'E':
                                        case 'F':
                                        case 'a':
                                        case 'b':
                                        case 'c':
                                        case 'd':
                                        case 'e':
                                        case 'f':
                                          {
                                            yyRepetition1 = yyIndex;
                                            continue;
                                          }

                                        default:
                                          /* No match. */
                                        }
                                      }
                                    }
                                    break;

                                  default:
                                    /* No match. */
                                  }
                                }
                              }
                              break;

                            default:
                              /* No match. */
                            }
                          }
                        }
                        break;

                      default:
                        /* No match. */
                      }
                    }
                  }
                  break;

                default:
                  /* No match. */
                }
              }

              // Nested alternative 2.
              { // Start scope for nested choice.

                final int yyChoice3 = yyChoice2;

                // Nested alternative 1.

                yyC = character(yyChoice3);
                if (-1 != yyC) {
                  yyIndex = yyChoice3 + 1;

                  switch (yyC) {
                  case '0':
                  case '1':
                  case '2':
                  case '3':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;

                        switch (yyC) {
                        case '0':
                        case '1':
                        case '2':
                        case '3':
                        case '4':
                        case '5':
                        case '6':
                        case '7':
                          {
                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;

                              switch (yyC) {
                              case '0':
                              case '1':
                              case '2':
                              case '3':
                              case '4':
                              case '5':
                              case '6':
                              case '7':
                                {
                                  yyRepetition1 = yyIndex;
                                  continue;
                                }

                              default:
                                /* No match. */
                              }
                            }
                          }
                          break;

                        default:
                          /* No match. */
                        }
                      }
                    }
                    break;

                  default:
                    /* No match. */
                  }
                }

                // Nested alternative 2.

                yyC = character(yyChoice3);
                if (-1 != yyC) {
                  yyIndex = yyChoice3 + 1;

                  switch (yyC) {
                  case '0':
                  case '1':
                  case '2':
                  case '3':
                  case '4':
                  case '5':
                  case '6':
                  case '7':
                    {
                      final int yyChoice4 = yyIndex;

                      // Nested alternative 1.

                      yyC = character(yyChoice4);
                      if (-1 != yyC) {
                        yyIndex = yyChoice4 + 1;

                        switch (yyC) {
                        case '0':
                        case '1':
                        case '2':
                        case '3':
                        case '4':
                        case '5':
                        case '6':
                        case '7':
                          {
                            yyRepetition1 = yyIndex;
                            continue;
                          }

                        default:
                          /* No match. */
                        }
                      }

                      // Nested alternative 2.

                      yyRepetition1 = yyChoice4;
                      continue;
                    }

                  default:
                    /* No match. */
                  }
                }
              } // End scope for nested choice.
            }
            break;

          default:
            /* No match. */
          }
        }

        // Nested alternative 2.

        yyC = character(yyChoice1);
        if (-1 != yyC) {
          yyIndex = yyChoice1 + 1;

          switch (yyC) {
          case '\"':
          case '\\':
            /* No match. */
            break;

          default:
            {
              yyRepetition1 = yyIndex;
              continue;
            }
          }
        }
        break;
      }

      yyC = character(yyRepetition1);
      if ('\"' == yyC) {
        yyIndex = yyRepetition1 + 1;

        yyValue = difference(yyStart, yyIndex);

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("string literal token expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.ClassName.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pClassName(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fClassName) 
      yyColumn.chunk4.fClassName = pClassName$1(yyStart);
    return yyColumn.chunk4.fClassName;
  }

  /** Actually parse orc.parser.OrcParserRats.ClassName. */
  private Result pClassName$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pClassNameToken(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSpace(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.ClassNameToken.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pClassNameToken(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyRepetition1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWordToken(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyRepetition1 = yyResult.index;
      while (true) {

        yyC = character(yyRepetition1);
        if ('.' == yyC) {
          yyIndex = yyRepetition1 + 1;

          yyResult = pWordToken(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyRepetition1 = yyResult.index;
            continue;
          }
        }
        break;
      }

      yyValue = difference(yyStart, yyRepetition1);

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    yyError = yyError.select("class name token expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.Identifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIdentifier(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fIdentifier) 
      yyColumn.chunk4.fIdentifier = pIdentifier$1(yyStart);
    return yyColumn.chunk4.fIdentifier;
  }

  /** Actually parse orc.parser.OrcParserRats.Identifier. */
  private Result pIdentifier$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWordToken(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSpace(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.WordToken.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pWordToken(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fWordToken) 
      yyColumn.chunk4.fWordToken = pWordToken$1(yyStart);
    return yyColumn.chunk4.fWordToken;
  }

  /** Actually parse orc.parser.OrcParserRats.WordToken. */
  private Result pWordToken$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if ((('A' <= yyC) && (yyC <= 'Z')) ||
          ('_' == yyC) ||
          (('a' <= yyC) && (yyC <= 'z'))) {

        yyResult = pWordToken$$Star1(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = difference(yyStart, yyResult.index);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("word token expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal orc.parser.OrcParserRats.WordToken$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pWordToken$$Star1(final int yyStart) throws IOException {
    OrcParserRatsColumn yyColumn = (OrcParserRatsColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fWordToken$$Star1) 
      yyColumn.chunk4.fWordToken$$Star1 = pWordToken$$Star1$1(yyStart);
    return yyColumn.chunk4.fWordToken$$Star1;
  }

  /** Actually parse orc.parser.OrcParserRats.WordToken$$Star1. */
  private Result pWordToken$$Star1$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if ((('0' <= yyC) && (yyC <= '9')) ||
          (('A' <= yyC) && (yyC <= 'Z')) ||
          ('_' == yyC) ||
          (('a' <= yyC) && (yyC <= 'z'))) {

        yyResult = pWordToken$$Star1(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = null;

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.DEF.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDEF(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('d' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('e' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('f' == yyC) {
          yyIndex = yyIndex + 1;

          yyResult = pSpace(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = yyStart;

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("DEF expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.TRUE.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTRUE(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('t' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('r' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('u' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyResult = pSpace(yyIndex);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyValue = yyStart;

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("TRUE expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.FALSE.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFALSE(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('f' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('a' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('l' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('s' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('e' == yyC) {
              yyIndex = yyIndex + 1;

              yyResult = pSpace(yyIndex);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyValue = yyStart;

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("FALSE expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.VAL.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pVAL(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('v' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('a' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('l' == yyC) {
          yyIndex = yyIndex + 1;

          yyResult = pSpace(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = yyStart;

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("VAL expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.CLASS.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCLASS(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('c' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('l' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('a' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('s' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('s' == yyC) {
              yyIndex = yyIndex + 1;

              yyResult = pSpace(yyIndex);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyValue = yyStart;

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("CLASS expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.SITE.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSITE(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('s' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('i' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('t' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyResult = pSpace(yyIndex);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyValue = yyStart;

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("SITE expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.NULL.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNULL(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('n' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('u' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('l' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('l' == yyC) {
            yyIndex = yyIndex + 1;

            yyResult = pSpace(yyIndex);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyValue = yyStart;

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("NULL expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.STOP.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSTOP(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('s' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('t' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('o' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('p' == yyC) {
            yyIndex = yyIndex + 1;

            yyResult = pSpace(yyIndex);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyValue = yyStart;

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("STOP expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.INCLUDE.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pINCLUDE(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('i' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('n' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('c' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('l' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('u' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('d' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('e' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyResult = pSpace(yyIndex);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyValue = yyStart;

                    return yyResult.createValue(yyValue, yyError);
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("INCLUDE expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.LAMBDA.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLAMBDA(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('l' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('a' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('m' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('b' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('d' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('a' == yyC) {
                yyIndex = yyIndex + 1;

                yyResult = pSpace(yyIndex);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyValue = yyStart;

                  return yyResult.createValue(yyValue, yyError);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("LAMBDA expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.AS.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAS(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('a' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('s' == yyC) {
        yyIndex = yyIndex + 1;

        yyResult = pSpace(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = yyStart;

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("AS expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.EQ.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEQ(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('=' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pSpace(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = yyStart;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("EQ expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.LANGLE.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLANGLE(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('<' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pSpace(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = yyStart;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("LANGLE expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.RANGLE.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRANGLE(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('>' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pSpace(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = yyStart;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("RANGLE expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.LPAREN.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLPAREN(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('(' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pSpace(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = yyStart;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("LPAREN expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.RPAREN.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRPAREN(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (')' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pSpace(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = yyStart;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("RPAREN expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.LBRACKET.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLBRACKET(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('[' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pSpace(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = yyStart;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("LBRACKET expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.RBRACKET.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRBRACKET(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (']' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pSpace(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = yyStart;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("RBRACKET expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.DOT.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDOT(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('.' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pSpace(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = yyStart;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("DOT expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.BANG.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBANG(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('!' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pSpace(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = yyStart;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("BANG expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.BAR.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBAR(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('|' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pSpace(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = yyStart;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("BAR expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.UNDERSCORE.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pUNDERSCORE(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('_' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pSpace(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = yyStart;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("UNDERSCORE expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.COMMA.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCOMMA(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (',' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pSpace(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = yyStart;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("COMMA expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.SEMICOLON.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSEMICOLON(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (';' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pSpace(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = yyStart;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("SEMICOLON expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.ANDAND.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pANDAND(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('&' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('&' == yyC) {
        yyIndex = yyIndex + 1;

        yyResult = pSpace(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = yyStart;

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("ANDAND expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.OROR.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pOROR(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('|' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('|' == yyC) {
        yyIndex = yyIndex + 1;

        yyResult = pSpace(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = yyStart;

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("OROR expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.NOT.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNOT(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('~' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pSpace(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = yyStart;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("NOT expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.PLUS.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPLUS(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('+' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pSpace(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = yyStart;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("PLUS expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.MINUS.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMINUS(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('-' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pSpace(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = yyStart;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("MINUS expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.DIV.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDIV(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('/' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pSpace(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = yyStart;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("DIV expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.MOD.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMOD(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('%' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pSpace(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = yyStart;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("MOD expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.TIMES.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTIMES(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('*' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pSpace(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = yyStart;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("TIMES expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.COLON.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCOLON(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (':' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pSpace(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = yyStart;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("COLON expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.LT.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLT(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('<' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if (':' == yyC) {
        yyIndex = yyIndex + 1;

        yyResult = pSpace(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = yyStart;

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("LT expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.LEQ.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLEQ(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('<' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('=' == yyC) {
        yyIndex = yyIndex + 1;

        yyResult = pSpace(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = yyStart;

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("LEQ expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.GT.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pGT(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (':' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('>' == yyC) {
        yyIndex = yyIndex + 1;

        yyResult = pSpace(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = yyStart;

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("GT expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.GEQ.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pGEQ(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('>' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('=' == yyC) {
        yyIndex = yyIndex + 1;

        yyResult = pSpace(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = yyStart;

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("GEQ expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.NEQ.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNEQ(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('/' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('=' == yyC) {
        yyIndex = yyIndex + 1;

        yyResult = pSpace(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = yyStart;

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("NEQ expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.Space.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSpace(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    boolean    yyPredMatched;
    int        yyBase;
    int        yyRepetition1;
    int        yyRepetition2;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    while (true) {

      final int yyChoice1 = yyRepetition1;

      // Nested alternative 1.

      yyC = character(yyChoice1);
      if (-1 != yyC) {
        yyIndex = yyChoice1 + 1;

        switch (yyC) {
        case ' ':
          {
            yyRepetition1 = yyIndex;
            continue;
          }

        case '\t':
          {
            yyRepetition1 = yyIndex;
            continue;
          }

        case '\f':
          {
            yyRepetition1 = yyIndex;
            continue;
          }

        case '\r':
          {
            yyRepetition1 = yyIndex;
            continue;
          }

        case '\n':
          {
            yyRepetition1 = yyIndex;
            continue;
          }

        case '-':
          {
            yyC = character(yyIndex);
            if (-1 != yyC) {
              yyIndex = yyIndex + 1;
              if ('-' == yyC) {

                yyRepetition2 = yyIndex;
                while (true) {

                  yyC = character(yyRepetition2);
                  if (-1 != yyC) {
                    yyIndex = yyRepetition2 + 1;

                    switch (yyC) {
                    case '\n':
                    case '\r':
                      /* No match. */
                      break;

                    default:
                      {
                        yyRepetition2 = yyIndex;
                        continue;
                      }
                    }
                  }
                  break;
                }

                final int yyChoice2 = yyRepetition2;

                // Nested alternative 1.

                yyC = character(yyChoice2);
                if (-1 != yyC) {
                  yyIndex = yyChoice2 + 1;

                  switch (yyC) {
                  case '\r':
                    {
                      final int yyChoice3 = yyIndex;

                      // Nested alternative 1.

                      yyC = character(yyChoice3);
                      if (-1 != yyC) {
                        yyIndex = yyChoice3 + 1;
                        if ('\n' == yyC) {

                          yyRepetition1 = yyIndex;
                          continue;
                        }
                      }

                      // Nested alternative 2.

                      yyRepetition1 = yyChoice3;
                      continue;
                    }

                  case '\n':
                    {
                      yyRepetition1 = yyIndex;
                      continue;
                    }

                  default:
                    /* No match. */
                  }
                }

                // Nested alternative 2.

                yyPredMatched = false;

                yyC = character(yyChoice2);
                if (-1 != yyC) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyRepetition1 = yyChoice2;
                  continue;
                } else {
                  yyError = yyError.select("space expected", yyStart);
                }
              }
            }
          }
          break;

        case '{':
          {
            yyC = character(yyIndex);
            if (-1 != yyC) {
              yyIndex = yyIndex + 1;
              if ('-' == yyC) {

                yyRepetition2 = yyIndex;
                while (true) {

                  final int yyChoice2 = yyRepetition2;

                  // Nested alternative 1.

                  yyC = character(yyChoice2);
                  if (-1 != yyC) {
                    yyIndex = yyChoice2 + 1;

                    switch (yyC) {
                    case '-':
                      {
                        yyPredMatched = false;

                        yyC = character(yyIndex);
                        if ('}' == yyC) {

                          yyPredMatched = true;
                        }

                        if (! yyPredMatched) {

                          yyRepetition2 = yyIndex;
                          continue;
                        } else {
                          yyError = yyError.select("space expected", yyStart);
                        }
                      }
                      break;

                    case '\r':
                      {
                        final int yyChoice3 = yyIndex;

                        // Nested alternative 1.

                        yyC = character(yyChoice3);
                        if (-1 != yyC) {
                          yyIndex = yyChoice3 + 1;
                          if ('\n' == yyC) {

                            yyRepetition2 = yyIndex;
                            continue;
                          }
                        }

                        // Nested alternative 2.

                        yyRepetition2 = yyChoice3;
                        continue;
                      }

                    case '\n':
                      {
                        yyRepetition2 = yyIndex;
                        continue;
                      }

                    default:
                      /* No match. */
                    }
                  }

                  // Nested alternative 2.

                  yyC = character(yyChoice2);
                  if (-1 != yyC) {
                    yyIndex = yyChoice2 + 1;

                    switch (yyC) {
                    case '\n':
                    case '\r':
                    case '-':
                      /* No match. */
                      break;

                    default:
                      {
                        yyRepetition2 = yyIndex;
                        continue;
                      }
                    }
                  }
                  break;
                }

                yyBase = yyRepetition2;
                yyC    = character(yyBase);
                if ('-' == yyC) {
                  yyIndex = yyRepetition2 + 1;

                  yyC = character(yyIndex);
                  if ('}' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyRepetition1 = yyIndex;
                    continue;
                  } else {
                    yyError = yyError.select("\"-}\" expected", yyBase);
                  }
                } else {
                  yyError = yyError.select("\"-}\" expected", yyBase);
                }
              }
            }
          }
          break;

        default:
          /* No match. */
        }
      }
      break;
    }

    yyValue = null;

    return new SemanticValue(yyValue, yyRepetition1, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal orc.parser.OrcParserRats.EndOfFile.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEndOfFile(final int yyStart) throws IOException {
    int        yyC;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyC = character(yyStart);
    if (-1 != yyC) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyValue = null;

      return new SemanticValue(yyValue, yyStart, yyError);
    } else {
      yyError = yyError.select("end of file expected", yyStart);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
  * Attach a source index to a semantic value.
  */
  private static class Indexed<E> {
    public E value;
    public int index;
    public Indexed(E value, int index) {
      this.value = value;
      this.index = index;
    }
  }
  /**
  * Attach a source location to a node.
  * It's really only necessary to use this with nodes
  * that could end up generating token errors where we'd
  * need to know the source location.
  */
  private <E extends Locatable> E at(int start, E e) {
    Location l = location(start);
    e.setSourceLocation(new SourceLocation(l.file, l.line, l.column));
    return e;
  }

}
