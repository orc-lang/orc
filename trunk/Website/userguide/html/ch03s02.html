<html><head><META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>3.2.&nbsp; class Sites</title><meta content="DocBook XSL Stylesheets V1.74.0" name="generator"><link rel="home" href="index.html" title="Orc User Guide v1.1.0"><link rel="up" href="ch03.html" title="Chapter&nbsp;3.&nbsp;Accessing and Creating External Services"><link rel="prev" href="ch03.html" title="Chapter&nbsp;3.&nbsp;Accessing and Creating External Services"><link rel="next" href="ch03s03.html" title="3.3.&nbsp; site Sites"><link href="/orchard/orc.css" type="text/css" rel="stylesheet"><link href="style.css" type="text/css" rel="stylesheet"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table summary="Navigation header" width="100%"><tr><th align="center" colspan="3">3.2.&nbsp;

                class Sites</th></tr><tr><td align="left" width="20%"><a accesskey="p" href="ch03.html">Prev</a>&nbsp;</td><th align="center" width="60%">Chapter&nbsp;3.&nbsp;Accessing and Creating External Services</th><td align="right" width="20%">&nbsp;<a accesskey="n" href="ch03s03.html">Next</a></td></tr></table><hr></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="section.services.java"></a>3.2.&nbsp;

                <code class="code"><span class="hl-keyword">class</span></code> Sites</h2></div></div></div><p>
Java classes can be imported into Orc as sites using the <a class="link" href="ch01s04.html#section.orc.class" title="1.4.4.1.&nbsp; class declaration">

                    <code class="code"><span class="hl-keyword">class</span></code> declaration</a>.
Imported classes must be in the classpath of the JVM running the Orc
interpreter.  The following sections describe in detail how such imported
classes behave in Orc programs.
</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="section.services.java.dot"></a>3.2.1.&nbsp;Dot Operator</h3></div></div></div><p>
<code class="code"><span class="hl-variable">x</span>.<span class="hl-variable">member</span></code>, where <code class="code"><span class="hl-variable">x</span></code> evaluates to a Java class or object, is evaluated as follows:
<div class="itemizedlist"><ul type="disc"><li>If <code class="code"><span class="hl-variable">x</span></code> has one or more methods named <code class="code"><span class="hl-variable">member</span></code>,
a "method handle" site is returned which may be called like any other Orc site.
When a method handle is actually called with arguments, the appropriate Java
method is selected and called depending on the number and type of arguments, as
described in <a class="link" href="ch03s02.html#section.services.java.method" title="3.2.4.&nbsp;Method Resolution">Method Resolution</a>
below.</li><li>Otherwise, if <code class="code"><span class="hl-variable">x</span></code> has a field named <code class="code"><span class="hl-variable">member</span></code>,
the object's field is returned, encapsulated in a <a class="link" href="apbs03.html#orc.lib.state.Ref">
                                <code class="code"><span class="hl-variable">Ref</span></code> object</a>. The
<code class="code"><span class="hl-variable">Ref</span></code> object has <code class="code"><span class="hl-variable">read</span></code> and <code class="code"><span class="hl-variable">write</span></code> methods
which are used to get and set the value of the field.</li></ul></div>
</p><p>
Note that no distinction is made between static and non-static members; it is
an error to reference a non-static member through a class, but this does not
change how members are resolved.  Note also that if a field shares a name with
one or more methods, there is no way to access the field directly.
</p><p>
The following (rather useless) example illustrates how the dot operator can be
used to access both static and non-static methods and fields:
<pre class="programlisting">
<span class="hl-comment">{- bind Integer to a Java class -}</span>
<span class="hl-keyword">class</span> <span class="hl-variable">Integer</span> = <span class="hl-variable">java</span>.<span class="hl-variable">lang</span>.<span class="hl-variable">Integer</span>

<span class="hl-comment">{- call a static method -}</span>
<span class="hl-keyword">val</span> <span class="hl-variable">i</span> = <span class="hl-variable">Integer</span>.<span class="hl-site">decode</span>(<span class="hl-literal">"5"</span>)
<span class="hl-comment">{- read a field -}</span>
<span class="hl-keyword">val</span> <span class="hl-variable">m</span> = <span class="hl-variable">Integer</span>.<span class="hl-variable">MIN_VALUE</span>.<span class="hl-site">read</span>()
<span class="hl-comment">{- write a field -}</span>
<span class="hl-variable">Integer</span>.<span class="hl-variable">MIN_VALUE</span>.<span class="hl-site">write</span>(<span class="hl-literal">5</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span>
<span class="hl-comment">{- call a non-static method -}</span>
<span class="hl-variable">i</span>.<span class="hl-site">toString</span>()
</pre>
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N114B7"></a>3.2.2.&nbsp;Direct Calls</h3></div></div></div><p>
When <code class="code"><span class="hl-variable">x</span></code> evaluates to a Java object (but not a Java class), the syntax
<code class="code"><span class="hl-site">x</span>(...)</code> is equivalent to <code class="code"><span class="hl-variable">x</span>.<span class="hl-site">apply</span>(...)</code>.
</p><p>
When <code class="code"><span class="hl-variable">x</span></code> evaluates to a Java class, the syntax <code class="code"><span class="hl-site">x</span>(...)</code>
calls the class's constructor.  In case of overloaded constructors, the
appropriate constructor is chosen based on the number and types of arguments as
described in <a class="link" href="ch03s02.html#section.services.java.method" title="3.2.4.&nbsp;Method Resolution">Method Resolution</a>.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N114D1"></a>3.2.3.&nbsp;Pattern Matching</h3></div></div></div><p>
If <code class="code"><span class="hl-variable">C</span></code> is bound to a Java class, it can be used as a pattern.
A pattern <code class="code"><span class="hl-site">C</span>(<span class="hl-variable">x</span>)</code> matches any Java object of that class or
any of its subclasses. The variable <code class="code"><span class="hl-variable">x</span></code> is simply bound
to the object again; thus the matcher is just a partial identity function.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="section.services.java.method"></a>3.2.4.&nbsp;Method Resolution</h3></div></div></div><p>
When a method handle is called, the actual Java method called is chosen based
on the runtime types of the arguments, as follows:
<div class="orderedlist"><ol type="1"><li>If only one method has the appropriate number of arguments, that method is called.</li><li>Otherwise, each method taking the appropriate number of arguments is
	tested for type compatibility as follows, and the first matching method
	is called.
	<div class="orderedlist"><ol type="a"><li>Every argument is compared to the corresponding formal
		parameter type as follows. All arguments must match for the
		method to match.
		<div class="orderedlist"><ol type="i"><li>If the argument is null, then the argument matches</li><li>If the formal parameter type is primitive (int, char,
			float, ...) and the argument is an instance of a
			wrapper class, then the argument is unboxed (unwrapped)
			and coerced to the type of the formal parameter
			according to Java's standard rules for implicit
			widening coercions.</li><li>If the formal parameter type is a primitive numeric type
			and the argument is an instance of <code class="code">BigDecimal</code>,
			the argument is implicitly narrowed to the formal parameter type.</li><li>If the formal parameter type is a primitive integral type
			and the argument is an instance of <code class="code">BigInteger</code>,
			the argument is implicitly narrowed to the formal parameter type.</li><li>Otherwise, the argument must be a subtype of the formal parameter type.</li></ol></div></li></ol></div></li></ol></div>
</p><p>
The reason for the unusual implicit narrowing of <code class="code">BigDecimal</code> and
<code class="code">BigInteger</code> is that Orc numeric literals have these types, and it
would be awkward to have to perform an explicit conversion every time such a
value is passed to a Java method expecting a primitive.
</p><p>
Currently we do not implement specificity rules for choosing the best matching
method; the first matching method (according to some unspecified order) is
chosen.  Note also that we do not support varargs methods explicitly, but
instead varargs may be passed as an array of the appropriate type.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N1150D"></a>3.2.5.&nbsp;Orc values in Java</h3></div></div></div><p>
Orc values are implemented by Java objects, so in general any Orc value may be
passed to a site implemented in Java.  Standard Orc values have the following
Java types:
</p><div class="variablelist"><dl><dt><span class="term">string</span></dt><dd><code class="code">java.lang.String</code></dd><dt><span class="term">boolean</span></dt><dd><code class="code">java.lang.Boolean</code></dd><dt><span class="term">number</span></dt><dd><code class="code">java.lang.Number</code></dd><dt><span class="term">tuple</span></dt><dd><code class="code">orc.runtime.values.TupleValue</code></dd><dt><span class="term">list</span></dt><dd><code class="code">orc.runtime.values.ListValue</code></dd><dt><span class="term">function</span></dt><dd><code class="code">orc.runtime.values.Closure</code><p>Currently it is not possible to call Orc functions from Java code.</p></dd><dt><span class="term">site</span></dt><dd><code class="code">orc.runtime.values.Site</code><p>Currently it is not possible to directly call Orc sites from Java
code.  However if you are implementing a site yourself, you may provide methods
which can be called from Java code to invoke the behavior of the site.</p></dd></dl></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N11549"></a>3.2.6.&nbsp;Java Values in Orc</h3></div></div></div><p>
Java objects may be used directly as values anywhere in an Orc program.
Primitive Java values cannot be used directly in an Orc program, but are
automatically boxed (and unboxed) as necessary.
</p><p>
When both arguments of an arithmetic or comparison operator are Java numeric
types, the arguments are implicitly coerced to the widest of the two argument
types.  "Widest" is defined by the following relation, where "&gt;" means "is
wider than": BigDecimal &gt; Double &gt; Float &gt; BigInteger &gt; Long &gt; Integer &gt; Short
&gt; Byte
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="section.services.kilim"></a>3.2.7.&nbsp;Cooperative Scheduling and Concurrency</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="N11554"></a>3.2.7.1.&nbsp;Overview</h4></div></div></div><p>
In order to support massive concurrency efficiently in Java, Orc uses
cooperative threading.  Orc programs are broken into discrete steps which
are executed by a fixed-size thread pool.  This approach works for Orc
expressions, but the internals of an Orc site written in Java cannot be easily
broken down.  So Orc has two choices when it needs to call a local Java site:
</p><div class="itemizedlist"><ul type="disc"><li>Run the site call in a new thread.  This means site calls never
	unnecessarily block the Orc engine, but it introduces the
	potentially-unnecessary overhead of creating and context-switching
	threads.</li><li>Run the site call in the same thread as the Orc engine, which
is efficient and conserves thread resources but may block the engine from
making further progress until the site call finishes.</li></ul></div><p>
Fortunately, in practice most Orc site calls take a short, deterministic amount
of time to complete. Of those that don't, it's usually only because they are
blocked waiting for some external event, like another site call.  In this case,
instead of blocking the site can return control to the Orc engine, asking to
be run again when the external event occurs.  In typical Java applications this
kind of non-blocking behavior is implemented using callbacks (or in its most
general form, continuation passing).  Unfortunately this creates convoluted and
verbose code: what if you need to block in the middle of a <code class="code"><span class="hl-keyword">for</span></code> loop, for example?
</p><p>
<a class="link" href="http://kilim.malhar.net/" target="_top">Kilim</a> resolves this issue by
allowing programmers to write code in a natural blocking style and then
rewriting the bytecode to perform a form of CPS conversion, so that instead
of blocking the code actually returns control to a scheduler. Orc supports
Kilim, allowing site authors to write sites with internal concurrency and
blocking behavior which don't use Java threads and cooperate with the Orc
engine.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="N1156A"></a>3.2.7.2.&nbsp;Kilim Fundamentals</h4></div></div></div><p>
For a full introduction to <a class="link" href="http://kilim.malhar.net/" target="_top">Kilim</a>, see <a class="link" href="http://www.malhar.net/sriram/kilim/thread_of_ones_own.pdf" target="_top">A Thread of
One's Own</a>, by Sriram Srinivasan. In the following, we will cover just
enough to get you started writing Orc sites using Kilim.
</p><p>
Kilim introduces three key primitives:
<div class="variablelist"><dl><dt><span class="term">
<code class="code">Pausable</code>
</span></dt><dd><p>
This checked exception marks methods which may block. You should never catch
this exception, and you should always declare it even if you have already
declared <code class="code"><span class="hl-keyword">throws</span> Exception</code> or <code class="code"><span class="hl-keyword">throws</span> Throwable</code>.  In all other respects it follows the
normal rules for checked exceptions: an override can only throw it if the
superclass method throws it, and you must throw it if you call any method which
throws it.
</p><p>Originally Kilim used annotations to mark pausable methods. It turned
out that <span class="command"><strong>javac</strong></span> would sometimes manipulate code in ways which violate the
invariants regarding use of the annotation. Annotations also have the
disadvantage that the invariants on their use are not checked automatically by
tools like Eclipse.</p></dd><dt><span class="term">
<code class="code">Mailbox</code>
</span></dt><dd><p>
A multiple-producer, single-consumer queue used to communicate
between tasks. The most important methods are <code class="code">put(Object)</code>, which places an item in the
mailbox, and <code class="code">get()</code>, which blocks until the mailbox
is non-empty and then returns the first item.
</p></dd><dt><span class="term">
<code class="code">Task</code>
</span></dt><dd>
Kilim analogue of a <code class="code">Thread</code>. Every <code class="code">Pausable</code>
method must be run within a task. To create and run a task:

<pre class="programlisting">
<span class="hl-keyword">new</span> Task() {
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> execute() <span class="hl-keyword">throws</span> Pausable {
        <span class="hl-comment">// do some stuff</span>
    }
}.start();
</pre></dd></dl></div>
</p><p>
Together, these primitives allow you to write highly-concurrent Java programs
in a familiar threaded style.  Under the hood, Kilim can schedule any number of
concurrent tasks on a fixed number of physical threads, providing better
scalability and performance than possible with Java threads.
</p><p>
When writing Orc sites you rarely need to use tasks explicitly because every Orc
site call is implicitly run inside a Kilim task if necessary. Therefore all you need to do is mark
<code class="code">Pausable</code> methods. Here's a short example of a
buffer site written using Kilim <code class="code">Mailbox</code>es:

<pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> KilimBuffer&lt;V&gt; {
	<span class="hl-keyword">private</span> LinkedList&lt;Mailbox&lt;V&gt;&gt; waiters =
		<span class="hl-keyword">new</span> LinkedList&lt;Mailbox&lt;V&gt;&gt;();
	<span class="hl-keyword">private</span> LinkedList&lt;V&gt; buffer = <span class="hl-keyword">new</span> LinkedList&lt;V&gt;();
	<span class="hl-keyword">public</span> <span class="hl-keyword">synchronized</span> <span class="hl-keyword">void</span> put(V o) {
		Mailbox&lt;V&gt; waiter = waiters.poll();
		<span class="hl-keyword">if</span> (waiter != null) waiter.putnb(o);
		<span class="hl-keyword">else</span> buffer.add(o);
	}
	<span class="hl-keyword">public</span> <span class="hl-keyword">synchronized</span> V get() <span class="hl-keyword">throws</span> Pausable {
		V out = buffer.poll();
		<span class="hl-keyword">if</span> (out != null) <span class="hl-keyword">return</span> out;
		<span class="hl-keyword">else</span> {
			Mailbox&lt;V&gt; waiter = <span class="hl-keyword">new</span> Mailbox&lt;V&gt;();
			waiters.add(waiter);
			<span class="hl-keyword">return</span> waiter.get();
		}
	}
}</pre>
</p><p>Classes using Kilim can be imported like other Java classes using the Orc
<code class="code"><span class="hl-keyword">class</span></code> declaration.  For example, we can use the
<code class="code">KilimBuffer</code> class defined above:
<pre class="programlisting">
<span class="hl-keyword">class</span> <span class="hl-variable">Buffer</span> = <span class="hl-variable">orc</span>.<span class="hl-variable">lib</span>.<span class="hl-variable">state</span>.<span class="hl-variable">KilimBuffer</span>
<span class="hl-keyword">val</span> <span class="hl-variable">b</span> = <span class="hl-site">Buffer</span>()
  <span class="hl-site">Rtimer</span>(<span class="hl-literal">1000</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-variable">b</span>.<span class="hl-site">put</span>(<span class="hl-literal">"1 second later"</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span> <span class="hl-literal">null</span>
<span class="hl-combinator">|</span> <span class="hl-variable">b</span>.<span class="hl-site">get</span>()</pre>
</p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3>
The version of Kilim bundled with Orc does not support calls to pausable
methods in constructor arguments. For example, this does not work:
<pre class="programlisting">
<span class="hl-keyword">new</span> Foo(bar.pausable());
</pre>
The workaround is to use a temporary variable:
<pre class="programlisting">
Object tmp = bar.pausable();
<span class="hl-keyword">new</span> Foo(tmp);
</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="N115DD"></a>3.2.7.3.&nbsp;When you must block</h4></div></div></div><p>
Sometimes blocking is unavoidable, for example if a site must perform blocking
IO.  For such cases, Orc provides a utility method <code class="code">orc.runtime.Kilim#runThreaded(Callable)</code> which farms work
out to a thread pool.  The advantage of doing this over spawning your own
thread is that there is no chance of using too many threads; if no thread is
available, the method pauses until one becomes available.  The disadvantage is
that if you have too many Java methods which must communicate with each other
concurrently and can't use Mailboxes, there won't be enough threads for them
all and execution will deadlock.  This situation is sufficiently rare that
<code class="code">runThreaded</code> is usually the correct approach.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="N115EA"></a>3.2.7.4.&nbsp;Compiling Kilim Sites</h4></div></div></div><p>
Code which uses Kilim must be processed with the Kilim "weaver" after compiling
and before running.  The weaver is bundled with the Orc source code, or may be
downloaded separately from the <a class="link" href="http://www.malhar.net/sriram/kilim/" target="_top">Kilim project
	site</a>.
</p><p>
To process compiled classes, run <code class="code">kilim.tools.Weaver</code>.
If your <code class="filename">.class</code> files are in the
<code class="filename">build/</code> directory, you would run the weaver like this:
<span class="command"><strong>java -cp kilim.jar:build/ kilim.tools.Weaver -d build/ build/</strong></span>
</p><p>
The Orc source distribution includes an ant <span class="command"><strong>kilim</strong></span>
task (in <code class="filename">build.xml</code>) which weaves compiled classes in the
<code class="filename">build</code> directory.  If you are compiling Orc in Eclipse, an
Eclipse "Builder" is included which does this automatically whenever any source
files change.
</p></div></div></div><script type="text/javascript" src="/orchard/orc.js"></script><div class="navfooter"><hr><table summary="Navigation footer" width="100%"><tr><td align="left" width="40%"><a accesskey="p" href="ch03.html">Prev</a>&nbsp;</td><td align="center" width="20%"><a accesskey="u" href="ch03.html">Up</a></td><td align="right" width="40%">&nbsp;<a accesskey="n" href="ch03s03.html">Next</a></td></tr><tr><td valign="top" align="left" width="40%">Chapter&nbsp;3.&nbsp;Accessing and Creating External Services&nbsp;</td><td align="center" width="20%"><a accesskey="h" href="index.html">Home</a></td><td valign="top" align="right" width="40%">&nbsp;3.3.&nbsp;
                site Sites</td></tr></table></div></body></html>