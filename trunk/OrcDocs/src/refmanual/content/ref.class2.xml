<?xml version="1.0" encoding="UTF-8"?>
<!-- ref.class2.xml - DocBook source for an Orc reference manual chapter

     $Id: $

     Copyright (c) 2010 The University of Texas at Austin. All rights reserved.

     Use and redistribution of this file is governed by the license terms in
     the LICENSE file found in the project's top-level directory and also found at
     URL: http://orc.csres.utexas.edu/license.shtml .
  -->

<!-- Class -->
   <chapter xml:id="ref.class2">
      <title>Class</title>
      <para>
      	Class is an abstraction mechanism in Orc, much like function. It
		allows a programmer to code a site in Orc. More generally, a class can
		be used to: (1) Define object classes with methods, (2) Create new
		sites and extend behaviors of existing sites, (3) Allow concurrent
		method invocation on objects, and (4) Create active objects, whose
		executions may be based on time or other external stimulus, not
		necessarily explicitly called methods.
      </para>
	  <section xml:id="ref.class2.body"><title>Class</title>
	  <section xml:id="ref.class2.declaration">
		  <title>Declaration</title>
		  <para> A class is defined much like a a function, as shown below. </para>
		  <programlisting language="orc"><![CDATA[
def class Newset(n) = 
]]></programlisting>
		  <para> 
		  	The keyword <code>class</code> denotes that a class is being defined, not just a
			function.  A class definition may have parameters like a function
			definition. In particular, a class or class instance could be a parameter.
		  </para>
		  <para>
		  	The body of a class may include definitions of both functions and
			classes. The name of every definition in the body is exported to the
			surrounding scope as a dot method. A class body must include at least
			one definition, which could be a function or a class.
		  </para>
		  <para>
		  	A class may be defined as a set of clauses. In that case, each clausal
			body must include the definitions of the same set of functions and
			classes.
		  </para>
		  <example xml:id="ref.class2.declaration.example"><title>Defining a Set</title>
<programlisting language="orc-demo"><![CDATA[
-- Define a set of maximum length n.
-- Export methods "add", "remove" and "size".

def class Newset(n) =
 val b = BoundedBuffer(n) -- to store the elements of the set
 val ne = Ref(0)          -- number of elements currently in the set

 {- Add an element to the set if it is non-full.
   If the set is full, wait until the set becomes non-full.
   Return a signal on completion.
 -}
 def add(x) = b.put(x) >> ne := ne? + 1

 {- Remove some element from the set if it is non-empty.
   If the set is empty, wait until the set becomes non-empty.
   Return the removed value.
 -}
 def remove() = b.get() >x> ne := ne? - 1 >> x

 {- Return the size, i.e., the number of elements currently in the set
 -}
 def size() = ne?


 {- Goal -} stop
]]></programlisting>
		  </example>
	  </section>
	  <section xml:id="ref.class2.semantics">
		  <title>Semantics</title>
		  <para> A class call such as</para>
		  <programlisting language="orc"><![CDATA[
Newset(5)
]]></programlisting>
		  <para>
		  	creates and publishes a site (an instance of the class). The created
			site can be accessed through the methods defined for the
			class. Unlike goal expressions of functions, the publications of the
			goal expression of a class are ignored. Yet, the goal expression is
			executed, and its execution may have side effects.
		  </para>
		  <programlisting language="orc"><![CDATA[
{- Let st be an instance of Newset created through -}

  val st = Newset(5)

{- The methods defined in Newset can be applied as dot methods
on st, as shown below. -}

  st.add(3) >> st.add(5) >> st.remove() >x> st.size() >y> (x,y)
]]></programlisting>
	  <section xml:id="ref.class2.semantics.restrictions">
	  	<title>Restrictions</title>
	  	<para>
	  		A class definition obeys all the rules of function definition except:
	  	</para>
	  	<itemizedlist>
	  		<listitem><para>Any publication by the goal expression of a class is ignored.</para></listitem>
	  		<listitem><para>Each function defined within a class can publish at most once.</para></listitem>
	  	</itemizedlist>
	  </section>
	  <section xml:id="ref.class2.semantics.concurrent">
	  	<title>Concurrent Executions of Methods</title>
	  	<para>
	  		The methods of a class instance may be executed concurrently through
			concurrent invocations. The class must be designed for concurrent
			execution, otherwise the different executions may interfere. For
			example,
	  	</para>
	  	<programlisting language="orc"><![CDATA[
st.add(3) | st.add(5)
]]></programlisting>
		<para>may not add two items to <code>st</code> because of possible interference in their executions.</para>
	  </section>
	  <section xml:id="ref.class2.semantics.site">
	  	<title>Class Instance is a Site</title>
	  	<para>
	  		Calls to methods of a class instance are treated exactly like external site
			calls. Therefore,
		</para>
		<itemizedlist>
			<listitem><para>A call is not terminated prematurely by prune; see example below.</para></listitem>
			<listitem><para>Unlike calls to functions, calls to class methods are strict;
  							i.e., the call is made only when all the parameters are bound.</para></listitem>
		</itemizedlist>
		<programlisting language="orc"><![CDATA[
v <v< (st.add(3) >> true | Rtimer(1) >> false)
]]></programlisting>
		<para>		
			The value published by this expression is either <code>true</code> or <code>false</code>. In
			the first case, item 3 is added to <code>st</code>. In the second case, item 3 is
			also added to <code>st</code>; the call <code>st.add(3)</code> is not terminated when
			the execution of <code>Rtimer(1) >> false</code> is completed, though the
			publication of <code>st.add(3)</code> is subsequently ignored.
		</para>
	  </section>
	  <section xml:id="ref.class2.semantics.examples">
	  	<title>Longer Examples</title>
	  	<section>
	  	<title>Matrix Definition</title>
	  	<para>
	  		Orc's standard library supports only one dimensional arrays, and array
			indices always start at 0. We define a 2-dimensional Matrix whose
			row and column indices range over an arbitrary interval.
	  	</para>
	  	<example xml:id="ref.class2.semantics.examples.one"><title>Matrix Definition</title>
<programlisting language="orc-demo"><![CDATA[
def class Matrix((rowlo, rowhi), (collo, colhi)) =
 val mat = Array((rowhi - rowlo + 1) * (colhi - collo + 1))

 def access(i, j) = mat((i - rowlo) * (colhi - collo + 1) + j)

stop

----------------- Usage
val A = Matrix((-2, 0), (-1, 3)).access
A(-1, 2) := 5 >> A(-1, 2) := 3 >> A(-1, 2)?
]]></programlisting>
		  </example>
		  <para>
		  	Note: We have defined <code>A</code> as the "access" method of the defined
			matrix. This allows us to retrive and update the matrix elements using
			traditional notation.
		  </para>
		  </section>
		  <section>
		  <title>Create a Site</title>
		  <para>
		  	We create a site, <code>Cell</code>, that defines a write-once variable. It
			supports two methods: <code>read</code> blocks until the variable has been
			written, and then it returns its value; <code>write(v)</code> blocks forever if a value has
			already been written, otherwise it writes <code>v</code> as the value and
			publishes a <code>signal</code>.
		  </para>
		  <para>
		  	We use two library sites, <code>Semaphore</code> (to ensure blocking of write if a
			value has been written) and <code>Ref</code> to store the value.
		  </para>
		  <example xml:id="ref.class2.semantics.examples.two"><title>Create a Site</title>
<programlisting language="orc-demo"><![CDATA[
def class Cell() =
 val s = Semaphore(1)
 val r = Ref ()

 def write(v) = s.acquire() >> r := v
 def read() = r?

stop
]]></programlisting>
		  </example>
		  </section>
		  <section>
		  <title>Extend Functionality of an Existing Site</title>
		  <para>
		  	The <code>Buffer</code> site implements an unbounded channel. We add a new method,
			"length", that returns the number of items in the channel. We have to
			assign a name different from "Buffer", "Channel", to this class.
		  </para>
		  <example xml:id="ref.class2.semantics.examples.three"><title>Extend Functionality of an Existing Site</title>
<programlisting language="orc-demo"><![CDATA[
def class Channel() =
 val ch = Buffer()
 val chlen = Counter(0)

 def put(x) = ch.put(x) >> chlen.inc()
 def get() = ch.get() >x> chlen.dec() >> x
 def length() = chlen.value()

stop
]]></programlisting>
		  </example>
		  </section>
		  <section>
		  <title>Managing Concurrent Access</title>
		  <para>
		  	The methods of a class instance may be executed concurrently through
			concurrent invocations. Concurrent execution may cause interference,
			as in the example of the <code>Newset</code> example. Typically, semaphores are used to
			restrict access to methods and/or data. We rewrite <code>Newset</code> in which all
			accesses to shared data <code>ne</code> are protected using a semaphore.
		  </para>
		  <example xml:id="ref.class2.semantics.examples.four"><title>Managing Concurrent Access</title>
<programlisting language="orc-demo"><![CDATA[
def class Newset(n) =
 val b = BoundedBuffer(n)
 val (s , ne) = (semaphore(1) , Ref(0))

 {- Add an element to the set if it is non-full.
   If the set is full, wait until the set becomes non-full.
   Return a signal on completion.
 -}
 def add(x) = b.put(x) >> s.acquire() >> ne := ne? + 1 >> s.release()

 {- Remove some element from the set if it is non-empty.
   If the set is empty, wait until the set becomes non-empty.
   Return the removed value.
 -}
 def remove() = b.get() >x> s.acquire() >> ne := ne? - 1 >>
   s.release() >> x

 {- Return the size, i.e., the number of elements currently in the set
 -}
 def size() = s.acquire() ne? >x> s.release() >> x

stop
]]></programlisting>
		  </example>
		  </section>
		  <section>
		  <title>Computing with the Goal Expression</title>
		  <para>
		  	All the goal expressions shown so far have been merely <code>stop</code>. In the
			following example, the goal expression of class metro initiates an
			unending computation in which <code>tick</code> is printed every second; all the
			publications of the goal expression are ignored.
		  </para>
		  <example xml:id="ref.class2.semantics.examples.five"><title>Computing with the Goal Expression</title>
<programlisting language="orc-demo"><![CDATA[
def class metro() =

 def metronome() = signal | Rtimer(1000) >> metronome()

 {- Goal -} metronome() >> println("tick")

val _ = metro()
{- Goal of the whole program -}  stop
]]></programlisting>
		  </example>
		  </section>
		  <section>
		  <title>Stopwatch</title>
		  <example xml:id="ref.class2.semantics.examples.six"><title>Stopwatch</title>
<programlisting language="orc-demo"><![CDATA[
{-
A stopwatch allows the following operations:
 start(): (re)starts the stopwatch and publishes a signal
 halt():  stops the stopwatch and publishes its current value
-}

{-
Each instance of the stopwatch creates a new clock.

It also maintains two Ref variables:
timeshown: clock value when the last halt() was executed,
laststart: clock value when the last start() was executed.
 Initially, both variable values are 0.
-}

def class Stopwatch() =
 val clk = Clock() -- create a new instance of Clock with time value 0
 val (timeshown, laststart) = (Ref(0), Ref(0))

 def start() = laststart := clk()
 def halt() =
    timeshown := timeshown? + (clk() âˆ’ laststart?) >> timeshown?
stop
]]></programlisting>
		  </example>
		  </section>
	  </section>
	  </section>
	  
	  <section xml:id="ref.class2.links">
		  <title>Related Links</title>
		  
	  <informaltable frame="none">
  		<tgroup cols="1" align="left">
    	<thead>
      		<row>
        		<entry align="center">Related Reference Topics</entry>
        	</row>
    	</thead>
    	<tbody valign="top">
     		<row>
        		<entry><itemizedlist>
          			<listitem><para><olink targetdoc="ref.declarations.class" targetptr="ref.declarations.class">Class Declaration</olink></para></listitem>
          			<listitem><para><olink targetdoc="ref.syntax.EBNF" targetptr="ref.syntax.EBNF">EBNF Grammar</olink></para></listitem>
        		</itemizedlist></entry>
        	</row>
    	</tbody>
  		</tgroup>
	  </informaltable>
	  
	  <informaltable frame="none">
  		<tgroup cols="1" align="left">
    	<thead>
      		<row>
        		<entry align="left">Related Tutorial Sections</entry>
        	</row>
    	</thead>
    	<tbody valign="top">
     		<row>
        		<entry><itemizedlist>
          			<listitem><para><olink targetdoc="root" targetptr="section.language.class">Classes</olink></para></listitem>
          			<listitem><para><olink targetdoc="root" targetptr="section.language.class.examples">Class Examples</olink></para></listitem>
        		</itemizedlist></entry>
        	</row>
    	</tbody>
  		</tgroup>
	  </informaltable>
	  
	  </section>
	</section>
   </chapter>
