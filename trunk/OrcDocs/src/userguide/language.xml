<?xml version="1.0" encoding="UTF-8"?>

<chapter id="chapter.language" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
<title>The Orc Programming Language</title>

<section><title>Introduction</title>


<para>
This chapter describes the Orc programming language in three steps. In Section 1.2, we
discuss a small subset of Orc called Cor. Cor is a pure functional language,
which has no features for concurrency, has no state, and does not communicate 
with external services. Cor introduces us to the parts of Orc that are most familiar 
from existing programming languages, such as arithmetic operations, variables,
conditionals, and functions.
</para>

<para>
In Section 1.3, we consider Orc itself, which in addition to Cor, comprises 
external services and combinators for concurrent orchestration of those services. 
We show how Orc interacts with these external services, how the combinators can be
used to build up complex orchestrations from simple base expressions, and how the 
functional constructs of Cor take on new, subtler behaviors in the concurrent 
context of Orc.
</para>

<para>
In Section 1.4, we discuss some additional features of Orc that extend 
the basic syntax. These are useful for creating large-scale Orc programs, but 
they are not essential to the understanding of the language.
</para>
 
</section> 


<!-- Replace Cor with Orc everywhere, and fix minor inconsistencies which result  -->
<!-- Cut all reference material in this section. Maybe cut the entire section. -->
<section><title>Cor: A Functional Subset</title>

 
<para>
In this section we introduce Cor, a pure functional subset of the Orc language.
Users of functional programming languages such as Haskell and ML will already be 
familiar with many of the key concepts of Cor.  
</para>

<para>
A Cor program is an <firstterm id="terms.expression">expression</firstterm>. Cor expressions are built
up recursively from smaller expressions. Cor <firstterm>evaluates</firstterm> an expression
to reduce it to some simple <firstterm>value</firstterm> which cannot be evaluated further, 
for example a list of numbers or a Boolean truth value. This value is called the <firstterm>
result</firstterm> of the expression.
</para>

<para>
In the following subsections we introduce the concepts of Cor. First, we talk about
simple <firstterm id="terms.constant">constants</firstterm>, such as numbers and truth values, and the operations that we can perform
on those values. Then we introduce conditionals (<code>if then else</code>). Then we 
introduce variables and binding, as a way to give a name to the value of an expression. 
After that, we talk about constructing data structures, and examining those structures
using patterns. Lastly, we introduce functions.
</para> 


<section id="orc.constants"><title>Constants</title>
<para>
The simplest expression one can write is a constant. It evaluates trivially
to that constant value. 
</para>

<para>

Cor has three types of constants, and thus for the moment three types of values:

<itemizedlist>

<listitem>
Boolean: <code>true</code> and <code>false</code>
</listitem>

<listitem>
Number: <code> 5, -1, 2.71828, ... </code>
</listitem> 

<listitem>
String: <code>"orc"</code>, <code>"ceci n'est pas une |"</code>
</listitem>

</itemizedlist>
</para>

</section>

<section id="language.base.operators"><title>Operators</title>
<para>
Cor has a standard set of arithmetic, logical, and comparison operators.
As in most other programming languages, they are written in the usual 
infix style. They have Java-like operator precedence, which can be
overridden by adding parentheses.  
</para>

<para>
<itemizedlist><title>Examples</title>
<listitem><code>1+2</code> evaluates to <code>3</code>.</listitem>
<listitem><code>(98+2)*17</code> evaluates to <code>1700</code>.</listitem>
<listitem><code>4 = 20 / 5</code> evaluates to <code>true</code>.</listitem>
<listitem><code>3-5 >= 5-3 </code> evaluates to <code>false</code>.</listitem>
<listitem><code><![CDATA[true && (false || true)]]></code> evaluates to <code>true</code>.</listitem>
<listitem><code>"leap" + "frog"</code> evaluates to <code>"leapfrog"</code>.</listitem>
</itemizedlist>
</para>

<para>
Numbers with no decimal part, such as <code>3</code>, are treated as integers. Arithmetic operators with two integer arguments will perform
an integer operation and return an integer result; for example, <code>5 / 2</code> performs integer division and evaluates to <code>2</code>.
However, if either argument to an operator has a decimal part (even if it is trivial, as in <code>3.0</code>), the other argument will
be promoted, and a decimal operation will be peformed. For example, <code>5 / 2.0</code> and <code>5.0 / 2</code> both perform decimal
division and evaluate to <code>2.5</code>.
</para>

<section><title>Silent Expression</title>
<para>
There are situations where an expression evaluation is stuck, because it is attempting to perform 
some impossible operation and cannot compute a value. In that case, the expression is <firstterm>silent</firstterm>. 
An expression is also silent if it depends on the result of a silent subexpression. For example, the following
expressions are silent: <code>10/0</code>, <code>6 + false</code>, <code>3 + 1/0</code>, <code>4 + true = 5</code>.
</para>

<para>
Cor is a dynamically typed language. A Cor implementation does not statically
check the type correctness of an expression; instead, an expression with a type
error is simply silent when it is evaluated.
</para>

<warning>
Silent expressions can produce side effects.  For example, on encountering a
type error, Orc will print an error message to the console.  However the
expression containing the type error will not publish a value, and in this
respect it is silent.
</warning>

</section>

</section>


<section><title>Conditionals</title>

<para>
A conditional expression in Cor is of the form 
<code>if</code> E <code>then</code> F <code>else</code> G. 
Its meaning is similar to that in other languages: the value
of the expression is the value of F if and only if E evaluates to true, 
or the value of G if and only if E evaluates to false. Note that G is not
evaluated at all if E evaluates to true, and similarly F is not evaluated
at all if E evaluates to false. Thus, for example, evaluation of 
<code>if true then 2+3 else 1/0</code> does not evaluate <code>1/0</code>;
it only evaluates <code>2+3</code>.
</para>

<para>
Unlike other languages, expressions in Cor may be silent. If E is
silent, then the entire expression is silent. And if E evaluates to true 
but F is silent (or if E evaluates to false and G is silent) then the 
expression is silent.
</para>

<para>
Note that conditionals have lower precedence than any of the operators.
For example, <code>if false then 1 else 2 + 3</code> is equivalent to
<code>if false then 1 else (2 + 3)</code>, not <code>(if false then 1 else 2) + 3</code>.
</para>


<para>
<itemizedlist><title>Examples</title>
<listitem><code>if true then 4 else 5</code> evaluates to <code>4</code>.</listitem>
<listitem><code><![CDATA[if  2 < 3 && 5 < 4  then "blue" else "green"]]></code> evaluates to "green".</listitem>
<listitem><code>if  true || "fish"  then "yes" else "no"</code> is silent.</listitem>
<listitem><code>if  false || false  then 4+5 else 4+true</code> is silent.</listitem>
<listitem><code><![CDATA[if 0 < 5 then 0/5 else 5/0]]></code> evaluates to 0.</listitem>
</itemizedlist>
</para>


</section>


<section id="cor.variables"><title>Variables</title>

<para>
A <firstterm>variable</firstterm> can be bound to a value. A <firstterm>declaration</firstterm> binds one or
more variables to values. The simplest form of declaration is <code>val</code>, which 
evaluates an expression and binds its result to a variable. Declarations follow the rules of 
<link xlink:href="http://en.wikipedia.org/wiki/Lexical_scope">lexical scoping</link>.
</para>

<para>
<programlisting><![CDATA[
val x = 1 + 2
val y = x + x
]]></programlisting>

These declarations bind variable <code>x</code> to 3 and variable <code>y</code> to 6.
</para>


<para>
If the expression on the right side of a <code>val</code> is silent, then the variable is not bound, but 
evaluation of other declarations and expressions continues. If an evaluated expression depends on that
variable, that expression is silent.

<programlisting language="orc-demo"><![CDATA[
val x = 1/0
val y = 4+5
if false then x else y]]></programlisting>

Evaluation of the declaration <code>val y = 4+5</code> and the expression <code>if false then x else y</code>
may continue even though <code>x</code> is not bound. The expression evaluates to 9.

</para>

</section>


<section id="cor.data"><title>Data Structures</title>

<para>
Cor supports three basic data structures, <firstterm>tuples</firstterm>, <firstterm>lists</firstterm>, and <firstterm>records</firstterm>.
</para>

<section><title>Tuples</title>
<para>
A <firstterm>tuple expression</firstterm> is a comma-separated sequence of at least two 
expressions, enclosed by parentheses. Each expression is evaluated; the value of the whole 
tuple expression is a tuple containing each of these values in order. 
If any of the expressions is silent, then the whole tuple expression is silent.
</para>

<para>
<itemizedlist><title>Examples</title>
<listitem><code>(1+2, 7)</code> evaluates to <code>(3,7)</code>.</listitem>
<listitem><code><![CDATA[ ("true" + "false", true || false, true && false) ]]></code> evaluates to <code>("truefalse", true, false)</code>.</listitem>
<listitem><code>(2/2, 2/1, 2/0)</code> is silent.</listitem>
</itemizedlist>
</para>

</section>
 
<section><title>Lists</title>

<para>
A <firstterm>list expression</firstterm> is a comma-separated sequence of expressions enclosed by
square brackets. It may be of any length, including zero. Each expression is evaluated; the value 
of the whole list expression is a list containing each of these values in order.   
If any of the expressions is silent, then the whole list expression is silent.
</para>

<para>
<itemizedlist><title>Examples</title>
<listitem><code>[1,2+3] </code> evaluates to <code>[1,5]</code>.</listitem>
<listitem><code><![CDATA[ [true && true] ]]> </code> evaluates to <code>[true]</code>.</listitem>
<listitem><code>[]</code> evaluates vacuously to <code>[]</code>, the empty list.</listitem>
<listitem><code>[5, 5 + true, 5]</code> is silent.</listitem>
</itemizedlist>
</para>

<para>
There is also a concatenation (<firstterm>cons</firstterm>) operation on lists,
written F<code>:</code>G, where F and G are expressions. Its result is a new list whose first element is the 
value of F and whose remaining elements are the list value of G. The <code>:</code> operator is right associative,
so F<code>:</code>G<code>:</code>H is F<code>:(</code>G<code>:</code>H<code>)</code>.
</para>

<para>
<itemizedlist><title>Examples</title>
<listitem><code>(1+3):[2+5,6]</code> evaluates to <code>[4,7,6]</code>.</listitem>
<listitem><code>2:2:5:[] </code> evaluates to <code>[2,2,5]</code>.</listitem>
<listitem>Suppose <code>t</code> is bound to [3,5]. Then <code>1:t</code> evaluates to <code>[1,3,5]</code>.</listitem>
<listitem><code>2:3</code> is silent, because <code>3</code> is not a list.</listitem>
</itemizedlist>
</para>

</section>



<section><title>Records</title>

<para>
A <firstterm>record expression</firstterm> is a comma-separated sequence of elements of the form 
<emphasis>f</emphasis><code> = </code> E, enclosed by
record braces <code>{.</code> and <code>.}</code>, where each f is a field name and each E is an expression. 
Records may have any number of fields, including zero. Each expression is evaluated; the value 
of the whole record expression is a record containing an element for each field with its associated value. 
Order is irrelevant. If any of the expressions is silent, then the whole record expression is silent.
</para>

<para>
<itemizedlist><title>Examples</title>
<listitem><code>{. zero = 3 - 3, one = 0 + 1 .}</code> evaluates to <code>{. zero = 0, one = 1 .}</code>.</listitem>
<listitem><code>{. .}</code> evaluates to <code>{. .}</code>, the empty record.</listitem>
</itemizedlist>
</para>

Elements of records are accessed using a dot (<code>.</code>) syntax, as in most object oriented languages.
The expression <code>r.f</code> evaluates to the value associated with field <code>f</code> in record <code>r</code>.
If <code>f</code> is not present in <code>r</code>, the expression is silent.

<para>
Suppose <code>r = {. x = 0, y = 1 .}</code>
<itemizedlist><title>Examples</title>
<listitem><code>r.x</code> evaluates to <code>0</code>.</listitem>
<listitem><code>r.y</code> evaluates to <code>1</code>.</listitem>
<listitem><code>r.z</code> is silent.</listitem>
</itemizedlist>
</para>


<para>
Records can also be extended using the + operator. An expression <code>r + s</code>, where r and s are records, 
creates a new record which has all of the elements of <code>r</code> whose field names do not appear in <code>s</code>, and all
of the elements of <code>s</code>. In other words, <code>s</code> overrides <code>r</code>.
This use of <code>+</code> is left-associative and does not commute.
</para>

<para>
<itemizedlist><title>Examples</title>
<listitem><code>{. x = 0 .} + {. y = 1 .}</code> evaluates to <code>{. x = 0, y = 1 .}</code></listitem>
<listitem><code>{. x = 0, y = 1 .} + {. y = 2, z = 3 .}</code> evaluates to <code>{. x = 0, y = 2, z = 3 .}</code></listitem>
</itemizedlist>
</para>

</section>
 
</section>


<!--  TODO: add record patterns -->
<section xml:id="orc.language.patterns"><title>Patterns</title>

<para>
We have seen how to construct data structures. But how do we examine them, and use them? We use <firstterm>patterns</firstterm>.
</para>

<para>
A pattern is a powerful way to bind variables. When writing <code>val</code> declarations, instead of just
binding one variable, we can replace the variable name with a more complex pattern that follows the structure of the
value, and matches its components. A pattern's structure is called its <firstterm>shape</firstterm>; a
pattern may take the shape of any structured value except a record. A pattern can hierarchically match a value, going deep into its 
structure. It can also bind an entire structure to a variable.

</para>

<para>
<itemizedlist><title>Examples</title>
<listitem><code>val (x,y) = (2+3,2*3)</code> binds <code>x</code> to 5 and <code>y</code> to 6.</listitem>
<listitem>
<code>val [a,b,c] = ["one", "two", "three"]</code> binds <code>a</code> to "one", 
<code>b</code> to "two", and <code>c</code> to "three".
</listitem>
<listitem>
<code>val ((a,b),c) = ((1, true), (2, false))</code> binds <code>a</code> to 1, <code>b</code> to <code>true</code>,
and <code>c</code> to <code>(2,false)</code>.
</listitem>
</itemizedlist>
</para>

<para>
Note that a pattern may fail to match a value, if it does not have the same shape as that value. In a <code>val</code>
declaration, this has the same effect as evaluating a silent expression. No variable in the pattern is bound, and
if any one of those variables is later evaluated, it is silent.
</para>

<para>
It is often useful to ignore parts of the value that are not relevant. We can use the
wildcard pattern, written <code>_</code>, to do this; it matches any shape and binds no
variables.
</para>

<para>
<itemizedlist><title>Examples</title>
<listitem><code>val (x,_,_) = (1,(2,2),[3,3,3])</code> binds <code>x</code> to 1.</listitem>
<listitem><code>val [[_,x],[_,y]] = [[1,3],[2,4]]</code> binds <code>x</code> to 3 and <code>y</code> to 4.</listitem>
</itemizedlist>
</para>

</section>

<!--  TODO: link to advanced features, such as curried definition and guards -->
<section id="cor.functions"><title>Functions</title>

<para>
Like most other programming languages, Cor provides the capability to define <firstterm>functions</firstterm>,
which are expressions that have a defined name, and have some number of parameters. Functions are declared 
using the keyword <code>def</code>, in the following way.

<programlisting><![CDATA[
def add(x,y) = x+y
]]></programlisting>

The expression on the right of the <code>=</code> is called the <firstterm>body</firstterm> of the function.
</para>

<para>
After defining the function, we can <firstterm>call</firstterm> it. A call looks just like the left side of
the declaration except that the variable names (the <firstterm>formal parameters</firstterm>) have been 
replaced by expressions (the <firstterm>actual parameters</firstterm>). 
</para>

<para>
To evaluate a call, we treat it as a sequence of <code>val</code> declarations associating the formal
parameters with the actual parameters, followed by the body of the function. 

<programlisting><![CDATA[
{- Evaluation of add(1+2,3+4) -}
val x = 1+2
val y = 3+4
x+y
]]></programlisting>
</para>

<para>
<itemizedlist><title>Examples</title>
<listitem><code>add(10,10*10)</code> evaluates to <code>110</code>.</listitem>
<listitem><code>add(add(5,3),5)</code> evaluates to <code>13</code>.</listitem>
</itemizedlist>
</para>

<para>
Notice that the evaluation strategy of functions allows a call to proceed even if some of the actual
parameters are silent, so long as the values of those actual parameters are not used in the evaluation
of the body.

<programlisting language="orc-demo"><![CDATA[
def cond(b,x,y) = if b then x else y
cond(true, 3, 5/0)
]]></programlisting>

This evaluates to <code>3</code> even though <code>5/0</code> is silent, because <code>y</code> is not
needed.

</para>


<para>
A function definition or call may have zero arguments, in which case we write <code>()</code> for the arguments.

<programlisting><![CDATA[
def Zero() = 0
]]></programlisting>
</para>


<section><title>Recursion</title>

<para>
Functions can be recursive; that is, the name of a function may be used in its own body.

<programlisting><![CDATA[
def sumto(n) = if n < 1 then 0 else n + sumto(n-1)
]]></programlisting>

Then, <code>sumto(5)</code> evaluates to 15.
</para>  

<para>
Mutual recursion is also supported.

<programlisting><![CDATA[
def even(n) = 
  if (n > 0) then odd(n-1)
  else if (n < 0) then odd(n+1)
  else true
def odd(n) = 
  if (n > 0) then even(n-1)
  else if (n < 0) then even(n+1)
  else false
]]></programlisting>

There is no special keyword for mutual recursion; any contiguous sequence of function declarations is assumed to be 
mutually recursive.
</para>

</section>

<section id="cor.closures"><title>Closures</title>

<para>
Functions are actually values, just like any other value. Defining a function creates a special value called a 
<firstterm>closure</firstterm>; the name of the function is a variable and its bound value is the closure. Thus, 
a closure can be put into a data structure, or bound to some other variable, just like any other value.

<programlisting><![CDATA[
def a(x) = x-3
def b(y) = y*4
val funs = (a,b)
]]></programlisting>
</para>

<para>
Like any other value, a closure can be passed as an argument to another function. This means that Cor
supports <emphasis>higher-order</emphasis> functions.

<programlisting><![CDATA[
def onetwosum(f) = f(1) + f(2)
def triple(x) = x * 3
]]></programlisting>

Then, <code>onetwosum(triple)</code> is <code>triple(1) + triple(2)</code>, which is <code>1 * 3 + 2 * 3</code> which evaluates to <code>9</code>.

</para>

<para>
Since all declarations (including function declarations) in Cor are lexically scoped, these closures are
<emphasis>lexical closures</emphasis>. This means that when a closure is created, if the body of the
function contains any variables other than the formal parameters, the bindings for those variables are
stored in the closure. Then, when the closure is called, the evaluation of the function body uses those 
stored variable bindings.  
</para>


</section>

<section xml:id="orc.language.lambda"><title>Lambda</title>

<para>
Sometimes one would like to create a closure directly, without bothering to give it a name. 
There is a special keyword <code>lambda</code> for this purpose. By writing a function
definition without the keyword <code>def</code> and replacing the function name with
the keyword <code>lambda</code>, that definition becomes an expression which evaluates to a closure. 

<programlisting language="orc-demo"><![CDATA[
def onetwosum(f) = f(1) + f(2)

onetwosum( lambda(x) = x * 3 )
{- 
  identical to:
  def triple(x) = x * 3
  onetwosum(triple)
-}]]></programlisting>

Then, <code>onetwosum( lambda(x) = x * 3 )</code> evaluates to 9. 

</para>

<para>
Since a function defined using <code>lambda</code> has no name, it is not possible to define 
a recursive function in this way. Only <code>def</code> can create a recursive function.
</para>

</section>


<section xml:id="orc.language.clauses"><title>Clauses</title>

<para>
The combination of functions and pattern matching offers a powerful capability: 
<firstterm>clausal</firstterm> definition of functions. We can define expressions which execute 
different code depending on the structure of their arguments. 
</para>


<para>
Here's an example.

<programlisting><![CDATA[
def sum([]) = 0
def sum(h:t) = h + sum(t)
]]></programlisting>

<code>sum(l)</code> publishes the sum of the numbers in the list <code>l</code>. It has two clauses: 
one which matches the empty list, and one which matches any nonempty list. If its argument is an empty 
list, it returns 0, the appropriate sum for an empty list. If the argument is a nonempty list, it adds 
the first element of that list to the sum of all of the other elements. In this way, it recursively finds 
the sum of the list.
</para>

<para>
A function may have multiple clauses, each of which has a sequence of patterns to match each argument, 
and a body expression. Naturally, all clauses of a function must have the same number of arguments. Any 
contiguous sequence of definitions with the same name and different arguments is interpreted as a clausal 
definition, where each individual declaration is a clause of the larger function. 
</para>

<para>
When the function is called, the clauses are tried in the order in which they appear until a match is found. 
If no clause matches, the call remains silent.
</para>

<para>
We allow a new form of pattern which is very useful in clausal definition of functions: a constant pattern.
A constant pattern is a match only for the same constant value. We can use this to define the "base case"
of a recursive function in a straightforward way.

<programlisting><![CDATA[
{- Fibonacci numbers -}
def fib(0) = 1
def fib(1) = 1
def fib(n) = if (n < 0) then 0 else fib(n-1) + fib(n-2)
]]></programlisting>

This definition of the Fibonacci function is straightforward, but slow, due to the repeated work in recursive
calls to <code>fib</code>. We can define a linear-time version, again with the help of pattern matching:

<programlisting><![CDATA[
{- Alternate definition of the Fibonacci function -}

{- A helper function: find the pair (Fibonacci(n-1), Fibonacci(n)) -}
def H(0) = (1,1)
def H(n) = 
  val (x,y) = H(n-1)
  (y,x+y)

def fib(n) = 
  if (n < 0) then 0 
  else (
    val (x,_) = H(n) 
    x
  )
     
    
]]></programlisting>
</para>

<para>
As a more complex example of matching, consider the following function which takes
a list argument and returns a new list containing only the first <code>n</code> 
elements of the argument list. 

<programlisting><![CDATA[
def take(0,_) = []
def take(n,h:t) = if (n > 0) then h:(take(n-1,t)) else []
]]></programlisting>
</para>


<para>
Mutual recursion and clausal definitions are allowed to occur together. Here are two functions,
<code>stutter</code> and <code>mutter</code>, which are each mutually recursive, and each have
multiple clauses. <code>stutter(l)</code> returns <code>l</code> with every odd element repeated.
<code>mutter(l)</code> returns <code>l</code> with every even element repeated.

<programlisting><![CDATA[
def stutter([]) = []
def stutter(h:t) = h:h:mutter(t)
def mutter([]) = []
def mutter(h:t) = h:stutter(t)
]]></programlisting>

<code>stutter([1,2,3])</code> evaluates to <code>[1,1,2,3,3]</code>.
</para>

<para>
Clauses of mutually recursive functions may also be interleaved, to make
them easier to read.

<programlisting><![CDATA[
def even(0) = true
def odd(0) = false
def even(n) = odd(if n > 0 then n-1 else n+1)
def odd(n) = even(if n > 0 then n-1 else n+1)
]]></programlisting>

</para>

</section>

</section>

<section><title>Comments</title>
<para>
Cor has two kinds of comments.   

</para>

<para>
A line which begins with two dashes (<code>--</code>), preceded only by whitespace, is a single line comment.
The region from the two dashes to the next encountered newline, inclusive, is ignored.  
<programlisting><![CDATA[
-- This is a single line comment.
	 -- This is also a single line comment.
]]></programlisting>
</para>

<para>
Multi-line comments are enclosed by matching braces of the form <code><![CDATA[{- -}]]></code>. 
Multi-line comments may be nested. They may appear anywhere, even in the middle of an expression.

<programlisting><![CDATA[
{- 
   This is a
   multiline comment.
-}
   
{- Multiline comments {- can be nested -} -}

{- They may appear anywhere, -} 
1 + {- even in the middle of an expression. -} 2 + 3
]]></programlisting>

</para>

</section>

</section>



<section id="orc"><title>Orc: Orchestrating services</title>

<para>
Cor is a pure declarative language. It has no state, since variables are bound at most once 
and cannot be reassigned. Evaluation of an expression results in at most one value.
It cannot communicate with the outside world except by producing a value. The full 
Orc language transcends these limitations by incorporating the orchestration of external services.
We introduce the term <firstterm>site</firstterm> to denote an external service which can be
called from an Orc program.
</para>

<para>
As in Cor, an Orc program is an  <firstterm>expression</firstterm>; Orc expressions are built 
up recursively from smaller expressions. Orc is a superset of Cor, i.e., all Cor expressions are 
also Orc expressions. Orc expressions are <firstterm>executed</firstterm>, rather than evaluated; 
an execution may call external services and <firstterm id="terms.publish">publish</firstterm> some number of 
values (possibly zero). Different executions of the same expression may have completely different
behaviors; they may call different services, may receive different responses from the same site,
and may publish different values. Expressions in the functional subset, though, will display
the same behavior in all executions.
</para>

<para>
In the following sections we discuss the features of Orc. First, we discuss how Orc
communicates with external services. Then we introduce Orc's concurrency <firstterm>combinators</firstterm>,
which combine expressions into larger orchestrations and manage concurrent executions. 
We have already discussed the functional subset of Orc in our coverage of Cor, but we
reprise some of those topics; some Cor constructs exhibit new behaviors in the 
concurrent, stateful context of Orc.
</para>

		
<section xml:id="orc.sites"><title>Communicating with external services</title>

<para>
An Orc expression may be a site call. Sites are called using the same syntax as a 
function call, but with a slightly different meaning. Sites are introduced and bound 
to variables by a special declaration.  
</para>

<section xml:id="orc.sites.calling"><title>Calling a site</title>

<para>
Suppose that the variable <code>Google</code> is bound to a site which invokes the
Google search engine service in "I'm Feeling Lucky" mode. A call to <code>Google</code> 
looks just like a function call. Calling <code>Google</code> requests the URL of the top 
result for the given search term.

<programlisting><![CDATA[
{- Get the top search result for "computation orchestration" -}
Google("computation orchestration")
]]></programlisting>

Once the Google search service determines the top result, it sends a response. The site 
call then publishes that response. Note that the service might not respond: Google's 
servers might be down, the network might be down, or the search might yield no result URL.  
</para>

<para>
A site call sends only a single request to an external service and receives at most one
response. These restrictions have two important consequences. First, all of the information needed 
for the call must be present before contacting the service. Thus, site calls are strict; all 
arguments must be bound before the call can proceed. If any argument is silent, the call never occurs.
Second, a site call publishes at most one value, since at most one response is received.
</para>

<!--  maybe cut this -->
<para>
A call to a site has exactly one of the following effects: 

<orderedlist>
<listitem>The site returns a value, called its <firstterm>response</firstterm>.</listitem>
<listitem>The site communicates that it will never respond to the call; we say that the call has <firstterm>halted</firstterm></listitem>
<listitem>The site neither returns a value nor indicates that the call has halted; we say that the call is <firstterm>pending</firstterm>.</listitem>
</orderedlist>
</para>

<para>
In the last two cases, the site call is said to be silent. However, unlike a silent expression in Cor, 
a silent site call in Orc might perform some meaningful computation or communication; silence does 
not necessarily indicate an error. Since halted site calls and pending site calls are both silent,
they cannot usually be distinguished from each other; only the <link linkend="combinators.otherwise">
otherwise combinator</link> can tell the difference. 
</para>


<para>
A site is a value, just like an integer or a list. It may be bound to a variable, passed 
as an argument, or published by an execution, just like any other value.
</para> 

<para>
<programlisting><![CDATA[
{-
  Create a search site from a search engine URL,
  bind the variable Search to that site,
  then use that site to search for a term.
-}
val Search = SearchEngine("http://www.google.com/")
Search("first class value")
]]></programlisting>
</para>

<para>
A site is sometimes called only for its effect on the external world; its return
value is irrelevant. Many sites which do not need to return a meaningful value will
instead return a <firstterm>signal</firstterm>: a special value which carries no 
information (analogous to the unit value <code>()</code> in ML). The signal value
can be written as <code>signal</code> within Orc programs.


<programlisting language="orc-demo"><![CDATA[
{- 
  Use the 'println' site to print a string, followed by
  a newline, to an output console.
  The return value of this site call is a signal.
-}
println("Hello, World!")
]]></programlisting>
</para>


</section>


</section>


<section id="combinators"><title>The concurrency combinators of Orc</title>

<para>
Orc has four <firstterm>combinators</firstterm>: parallel, sequential, pruning, and otherwise. 
A combinator forms an expression from two component expressions. Each combinator captures a 
different aspect of concurrency. Syntactically, the combinators are written infix, and have
lower precedence than operators, but higher precedence than conditionals or declarations.
</para>

<section id="combinators.parallel"><title>The parallel combinator</title>

<para>
Orc's simplest combinator is <code>|</code>, the parallel combinator. Orc executes
the expression F <code>|</code> G, where F and G are Orc expressions, by executing 
F and G concurrently. Whenever F or G communicates with a service or publishes a value, 
F <code>|</code> G does so as well.  The resulting publications of F <code>|</code> G
may be published in arbitrary order.
</para>   

<para>
<programlisting language="orc-demo"><![CDATA[
-- Publish 1 and 2 in parallel  
1 | 1+1

-- Note the publication order may be either 1 then 2
-- or 2 then 1
]]></programlisting>
</para>  

<para>
<programlisting><![CDATA[
{- 
  Access two search sites, Google and Yahoo, in parallel.

  Publish any results they return.
  
  Since each call may publish a value, the expression
  may publish up to two values.
-}  
Google("cupcake") | Yahoo("cupcake")
]]></programlisting>
</para>  

<para>
<programlisting language="orc-demo"><![CDATA[
-- Publish 1, 2, and 3 in parallel  
1+0 | 1+1 | 1+2
]]></programlisting>
</para>  

<para>For more information, see the 
	<olink targetdoc="refmanual" targetptr="ref.combinators.parallel">
	Reference Manual (Parallel Combinator)	
	</olink>.
</para>

</section>

<section id="combinators.sequential"><title>The sequential combinator</title>

<para>
Now that we have expressions which publish multiple values, what can we do with those
publications? The sequential combinator, written F<code><![CDATA[ >x> ]]></code>G, 
combines the expression F, which may publish some values, with another expression G, 
which will use the values as they are published; <code>x</code> transmits the values
from F to G.
</para>

<para>
The execution of F<code><![CDATA[ >x> ]]></code>G starts by executing F. Whenever F publishes a value, 
a new instance of G is executed in parallel with F (and with any previous copies of G); in that
instance of G, variable <code>x</code> is bound to the value published by F. Values published by copies
of G are published by the whole expression, but the values published by F are not published
by the whole expression; they are consumed by the variable binding.
</para>

<para>
<programlisting language="orc-demo"><![CDATA[
-- Publish 1 and 2 in parallel  
(0 | 1) >n> n+1
]]></programlisting>
</para>  

<para>
<programlisting language="orc-demo"><![CDATA[
-- Publish 3 and 4 in parallel  
2 >n> (n+1 | n+2)
]]></programlisting>
</para>  


<para>
<programlisting language="orc-demo"><![CDATA[
-- Publish 0, 1, 2 and 3 in parallel  
(0 | 2) >n> (n | n+1)
]]></programlisting>
</para>  


<para>
<programlisting><![CDATA[
-- Prepend the site name to each published search result
-- The cat site concatenates any number of arguments into one string  
  Google("cupcake") >s> cat("Google: ", s)
| Yahoo("cupcake") >s> cat("Yahoo: ", s)
]]></programlisting>
</para>  




<para>
The sequential combinator may be written as F<code><![CDATA[ >]]></code>P<code><![CDATA[> ]]></code>G, 
where P is a pattern instead of just a variable name. Any value published by F is matched against the 
pattern P. If this match is successful, a new instance of G is started with all of the bindings from the match. 
Otherwise, the published value is simply ignored, and no new instance of G is executed.
</para>

<para>
<programlisting language="orc-demo"><![CDATA[
-- Publish 3, 6, and 9 in arbitrary order.
(3,6,9)  >(x,y,z)>  ( x | y | z )
]]></programlisting>
</para>


<para>
<programlisting language="orc-demo"><![CDATA[
-- Filter out values of the form (_,false)
( (4,true) | (5,false) | (6,true) )  >(x,true)> x
-- Publishes 4 and 6 
]]></programlisting>
</para>
 


<para>
We may also omit the variable entirely, writing <code><![CDATA[ >> ]]></code>. This
is equivalent to using a wildcard pattern: <code><![CDATA[ >_> ]]></code>
</para>

<para>
We may want to execute an expression just for its effects, and hide all of its publications.
We can do this using <code><![CDATA[ >> ]]></code> together with the special expression 
<code>stop</code>, which is always silent.  
</para>

<para>
<programlisting language="orc-demo"><![CDATA[
{- 
  Print two strings to the console,
  but don't publish the return values of the calls.
-}
( println("goodbye") | println("world") ) >> stop
]]></programlisting>
</para>

<para>
The sequential combinator makes it easy to bind variables in sequence and use
them together.
</para>

<para>
<programlisting language="orc-demo"><![CDATA[
{- 
  Publish the cross product of {1,2} and {3,4}:
  (1,3), (1,4), (2,3), and (2,4).
-}
(1 | 2) >x> (3 | 4) >y> (x,y)
]]></programlisting>
</para>


</section>


<section id="combinators.pruning"><title>The pruning combinator</title>

<para>
The pruning combinator, written F<code><![CDATA[ <x< ]]></code>G, allows us to block 
a computation waiting for a result, or terminate a computation. The execution of 
F<code><![CDATA[ <x< ]]></code>G starts by executing F and G in parallel. Whenever
F publishes a value, that value is published by the entire execution. When G publishes
its first value, that value is bound to x in F, and then the execution of G is immediately 
<firstterm>killed</firstterm>. A killed expression cannot call any sites or 
publish any values.
</para>

<para>
During the execution of F, any part of the execution that depends on <code>x</code> 
will be suspended until <code>x</code> is bound (to the first value published by G). If G
never publishes a value, that part of the execution is suspended forever. 
</para>

<para>
<programlisting language="orc-demo"><![CDATA[
-- Publish either 5 or 6, but not both
x+2 <x< (3 | 4)
]]></programlisting>
</para>  

<para>
<programlisting><![CDATA[
-- Query Google and Yahoo for a search result
-- Print out the result that arrives first; ignore the other result
println(result) <result< ( Google("cupcake") | Yahoo("cupcake") )
]]></programlisting>
</para>  

<para>
Though a terminated execution may not make any new calls, the calls
that it has already made will continue normally; their responses are simply
ignored. This may have surprising consequences when a call has side effects,
as in the following example.

<programlisting language="orc-demo"><![CDATA[
{- 
  This example actually prints both "true" and "false" to the
  console, regardless of which call responds first.
-}
stop <x< println("true") | println("false")
]]></programlisting>

Both of the <code>println</code> calls are initiated before either one of
them publishes a value and terminates the expression. Once the expression
is terminated, no new calls occur, but the other <code>println</code> call
still proceeds and still has the effect of printing its message to the
console.
</para>


<para>
The pruning combinator may include a full pattern P instead of just a variable name. Any
value published by G is matched against the pattern P. If this match is successful, then G
terminates and all of the bindings of the pattern P are made in F. Otherwise, the published 
value is simply ignored and G continues to execute.
</para>

<para>
<programlisting language="orc-demo"><![CDATA[
-- Publish either 9 or 25, but not 16.
x*x <(x,true)< ( (3,true) | (4,false) | (5,true) )
]]></programlisting>
</para>  

<para>
Note that even if <code>(4,false)</code> is published before <code>(3,true)</code> or <code>(5,true)</code>, 
it is ignored. The right side continues to execute and will publish one of <code>(3,true)</code> or 
<code>(5,true)</code>.
</para>

</section>


<section id="combinators.otherwise"><title>The otherwise combinator</title>

<para>
Orc has a fourth concurrency combinator: the <firstterm>otherwise</firstterm> combinator,
written F<code> ; </code>G. The execution of F<code> ; </code> G proceeds as follows.
First, F is executed. If F <firstterm>halts</firstterm>, and has not published any values, 
then G executes. If F did publish one or more values, then G is ignored. The publications of 
F <code>;</code> G are those of F if F publishes, or those of G otherwise.
</para>

<!-- TODO: may need a 1 sentence description of 'halts' -->
<!--  TODO: may need an example too -->
</section>



</section>



<section><title>Revisiting Cor expressions</title>

<para>
Some Cor expressions have new behaviors in the context of Orc, due to the introduction
of concurrency and of sites.
</para>


<!--  TODO: Cut -->
<section><title>Operators</title>

<para>
The arithmetic, logical, and comparison operators are actually calls to sites, simply
written in infix style with the expected operator symbols. For example, <code>2+3</code>
is actually <code>(+)(2,3)</code>, where <code>(+)</code> is a primitive site provided
by the language itself. All of the operators can be used directly as sites in this way;
the name of the site is the operator enclosed by parentheses, e.g. <code>(**)</code>,
<code>(>=)</code>, etc. Negation (unary minus) is named <code>(0-)</code>.
</para>

</section>

<!--  TODO: Cut -->
<section xml:id="orc.conditionals"><title>Conditionals</title>

<para>
The conditional expression <code>if</code> E <code>then</code> F <code>else</code> G
is actually a derived form based on two different sites named <code>If</code> and <code>Unless</code>. 
The sites take a boolean argument.  <code>If</code> returns a signal if that argument is <code>true</code>,
or remains silent if the argument is <code>false</code>.  <code>Unless</code> returns a signal if that argument
is <code>false</code> or remains silent if the argument is <code>true</code>.
</para>

<para>
<code>if</code> E <code>then</code> F <code>else</code> G is equivalent 
to <code>(<![CDATA[ If(b) >> ]]></code>F<code><![CDATA[ | Unless(b) >> ]]></code>G<code>)<![CDATA[ <b< ]]></code>E.
</para>

	
</section>

<!--  TODO: Move to val (variables) section from Cor, maybe inline with pruning combinator -->
<section><title><code>val</code></title>

<para>
The declaration <code>val x = </code>G, followed by expression F, is 
actually just a different way of writing the expression F<code><![CDATA[ <x< ]]></code>G.
Thus, <code>val</code> shares all of the behavior of the pruning combinator,
which we have already described. (This is also true when a pattern is used instead
of variable name <code>x</code>).
</para>

</section>


<section xml:id="expression.nesting"><title>Nesting Orc expressions</title>

<para>
The execution of an Orc expression may publish many values. What does such an expression 
mean in a context where only one value is expected? For example, what does <code>2 + (3 | 4)</code> 
publish? 
</para>

<para>
Whenever an Orc expression appears in such a context, it executes until it publishes its first value, 
and then it is terminated. The published value is used in the context as if it were the result of evaluating
the expression.
</para>

<para>
<programlisting language="orc-demo"><![CDATA[
-- Publish either 5 or 6
2 + (3 | 4)
]]></programlisting>
</para>

<para>
<programlisting language="orc-demo"><![CDATA[
-- Publish exactly one of 0, 1, 2 or 3
(0 | 2) + (0 | 1)
]]></programlisting>
</para>

<!--  TODO: Add link to deflation -->
<para>
To be precise, whenever an Orc expression appears in such a context, it is treated as if it was 
on the right side of a pruning combinator, using a fresh variable name to fill in the hole. 
Thus, C[E] (where E is the Orc expression and C is the context) is equivalent to the expression 
C[<code>x</code>] <code><![CDATA[ <x< ]]></code> E. 
</para>

</section>


<section><title>Functions</title>

<para>
The body of a function in Orc may be any Orc expression; thus, function
bodies in Orc are executed rather than evaluated, and may engage in communication
and publish multiple values.
</para>

<para>
A function call in Orc binds the values of its arguments
to the function's parameters, and then executes the function body in parallel with the
computation of the bindings. Whenever the function body publishes a value, the function call publishes that
value. Thus, unlike a site call, a function call may publish many values.
</para>

<para>
<programlisting language="orc-demo"><![CDATA[
-- Publish all integers in the interval 1..n, in arbitrary order. 
def range(n) = if (n > 0) then (n | range(n-1)) else stop 

-- Publish 1, 2, and 3 in arbitrary order.
range(3)
]]></programlisting>
</para>

<!--  TODO: link to deflation -->
<para>
In the context of Orc, function calls are not strict. When a function call executes,
it begins to execute the function body immediately, and also executes the argument
expressions in parallel. When an argument expression publishes a value, it is killed,
and the corresponding parameter is bound to that value in the execution of
the function body. Any part of the function body which uses a parameter
that has not yet been bound blocks until that parameter is bound to a value.
</para>


<!--  TODO: add example about blocking on function parameters -->

</section>



</section>


<section xml:id="orc.language.time"><title>Time</title>

<para>
Orc is designed to communicate with the external world, and one of the
most important characteristics of the external world is the passage of
time. Orc implicitly interacts with the passage of time by calling external
services which take time to respond. However, Orc can also explicitly
wait for some amount of time, using the special site <code>Rwait</code>. 
</para>

<!--  TODO: link approximately to ref manual -->
<para>
The site <code>Rwait</code> is a relative timer. It takes as an argument
a number of milliseconds to wait. It waits for approximately that amount of time,
and then responds with a signal.
</para>

<para>
<programlisting language="orc-demo"><![CDATA[
-- Print "red", wait for 3 seconds (3000 ms), and then print "green" 
println("red") >> Rwait(3000) >> println("green") >> stop
]]></programlisting>
</para>

<para>
The following example defines a metronome, which publishes a signal once 
every <code>t</code> milliseconds, indefinitely.
</para>

<para>
<programlisting><![CDATA[
def metronome(t) = signal | Rwait(t) >> metronome(t)
]]></programlisting>
</para>

<para>
We can also use <code>Rwait</code> together with the pruning combinator 
to enforce a timeout.
</para>

<para>
<programlisting><![CDATA[
{-
  Publish the result of a Google search.
  If it takes more than 5 seconds, time out.
-}
result 
  <result< ( Google("impatience") 
           | Rwait(5000) >> "Search timed out.")
]]></programlisting>
</para>


<!--  TODO: Change name from Chapter 2 to 'methodology' or some such -->
We present many more examples of programming techniques using real time in <link linkend="chapter.methodology">Chapter 2</link>.

</section>


</section>


<!-- TODO: keep dot access -->
<!-- TODO: keep datatypes -->
<!-- TODO: keep def class -->


<section><title>Advanced Features of Orc</title>

<section id="special.dot"><title>The <code>.</code> notation</title>

<para>
In many object-oriented programming languages, one calls a method or accesses a field of an
object using the dot operator; for example, <code>obj.m()</code> calls the method
<code>m</code> of the object <code>obj</code>. 
</para>

<para>
There is a special kind of site call in Orc which serves a similar purpose. One may write
<code>x.msg</code>, for any identifiers <code>x</code> and <code>msg</code>. This treats
 the value bound to <code>x</code> as a site, and calls it with a special 
<firstterm>message</firstterm> value <code>msg</code>. 
If the site understands the message <code>msg</code> (for example, if <code>x</code> is 
bound to a Java object with a field called <code>msg</code>), the site interprets the message 
and responds with some appropriate value. If the site does not 
understand the message sent to it, it does not respond, and no publication occurs. 
If <code>x</code> cannot be interpreted as a site, no call is made. 
</para>

<para>
Typically this capability is used so that sites may be syntactically treated like objects, 
with multiple methods and fields. For example, a channel <code>c</code> might understand the messages
<code>get</code> and <code>put</code>, to get values from and put values on that channel,
respectively. Such calls would be written <code>c.get()</code>, or <code>c.put(6)</code>.
</para>

<para>
A call such as <code>c.put(6)</code> actually occurs in two steps. First <code>c.put</code> sends the message
<code>put</code> to the site <code>c</code>; this publishes a site whose only purpose
is to put values on the channel. Next, that site is called on the argument
<code>6</code>, sending 6 on the channel. Readers familiar with functional programming
will recognize this technique as <emphasis>currying</emphasis>. <!--  TODO: link to ref manual: currying -->
</para>
</section>


<section id="section.orc.datatypes"><title>Datatypes</title>

<para>
We have seen Orc's predefined data structures: tuples and lists. Orc also provides the capability
for programmers to define their own data structures, using a feature adopted from the ML/Haskell
language family called <firstterm>datatypes</firstterm> (also called variants or tagged sums).
</para>

<para>
Datatypes are defined using the <code>type</code> declaration:

<programlisting><![CDATA[
type Tree = Node(_,_,_) | Empty()
]]></programlisting>

</para>

<para>
This declaration defines two new sites named <code>Node</code> and <code>Empty</code>.
<code>Node</code> takes three arguments, and publishes a <emphasis>tagged value</emphasis>
wrapping those arguments. <code>Empty</code> takes no arguments and does the same.
</para>

<para>
Once we have created these tagged values, we use a new pattern called a datatype pattern
to match them and unwrap the arguments:

<programlisting><![CDATA[
type Tree = Node(_,_,_) | Empty()
{- Build up a small binary tree -}
val l = Node(Empty(), 0, Empty())
val r = Node(Empty(), 2, Empty())
val t = Node(l,1,r)

{- And then match it to extract its contents -}
t >Node(l,j,r)>
l >Node(_,i,_)>
r >Node(_,k,_)>
( i | j | k )
]]></programlisting>
</para>

<para>
One pair of datatypes is so commonly used that it is already predefined in the standard library:
<code>Some(_)</code> and <code>None()</code>. These are used as return values for calls that
need to distinguish between successfully returning a value (<code>Some(v)</code>), and successfully
completing but having no meaningful value to return (<code>None()</code>). For example, a lookup
function might return <code>Some(result)</code> if it found a result, or return <code>None()</code>
if it successfully performed the lookup but found no suitable result.
</para>

</section>


<section id="section.language.class"><title>Classes</title>

<para>
A class is an abstraction mechanism in Orc, much like the
<code>def</code> construct. It extends the <code>def</code> construct, by allowing
us to convert an Orc program fragment into a site. Specifically, a
class can be used to: (1) Define object classes with methods,
(2) Create new sites and extend behaviors of existing sites, (3) Allow
concurrent method invocation on objects, and (4) Create active
objects, whose executions may be based on time or other external
stimulus, not necessarily explicitly called methods. 
</para>
	
<para>
A class has the following properties:
<orderedlist>
<listitem>Encapsulation: Just like objects in an object-oriented language, classes 
	also provide the encapsulation facility for the programmer. The data defined inside 
	the class can only be accessed and modified through methods defined in class. Therefore, 
	it hides the representation of the data and implementation of functions and methods 
	which work on the data and manage the state. </listitem>
<listitem>Methods instead of functions: These are the gateways to access and manipulate the 
	data represented by class. They also enable the user of the class to access the service 
	provided by that. Unlike functions in Orc, methods defined in a class can only publish 
	one value. </listitem>
<listitem>Termination protection: The execution of a class and its methods are protected from 
	termination of the rest of the program. In other words, the execution of class cannot be 
	interrupted. In the pruning combinator as soon as the right hand side expression publishes a 
	value, all the on going executions in the right hand side will be terminated. However, if there 
	is any call to a class in the right hand side, that call will proceed until completion. For 
	example, in the following Orc expression, suppose that c is a class.
	<programlisting><![CDATA[
	 y <y< g() | c() 
]]></programlisting>
	If g() publishes a value before c() does, the execution of c() will continue. Although, the published 
	value of c() (if any) will never be used. On the other hand, if c() publishes a value first, then the 
	execution of g() will be interrupted since its execution is not protected. This property of classes is 
	very important to prevent the data corruption and invalid state of an object. We will see using an 
	example the significance of this property later on in the guide. 
</listitem>
	<listitem>Strict calls: unlike calls to ordinary function definitions in Orc, calls to class methods 
		are strict. This means that the call will not happen unless all the parameters are bound. </listitem>
</orderedlist>
</para>

<para>
A class definition can be translated to pure Orc calculus, making
use of the site <code>makesite</code>. (See <xref linkend="appendix.library"/> for details of <code>makesite</code>.)
</para>

<section><title>Object Definition</title>

<para>
To motivate the notion of class, we start with a simple example, 
defining a stack with methods <code>push</code> and <code>pop</code>. Below, parameter <code>n</code>
defines the maximum length of each instance of stack. We store the
stack elements in an array. Our implementation blocks an illegal
operation (a <code>push</code> on a full stack or a <code>pop</code> on an empty stack).  
</para>

<programlisting><![CDATA[
def class Stack(n) =
  val store = Table(n, Ref)
  val len = Ref (0) -- len is the current stack length

  def push(x) = ift(len? <: n) >> store(len?) := x >> len := len? + 1

  def pop() = ift(len? :> 0) >> len := len? - 1 >> store(len?)?

  {- class goal -} stop

----------- Test
val st = Stack(5)
st.push(3) >> st.push(5) >> st.pop() >> st.pop()
]]></programlisting>

</section>


<section><title>Class Syntax and Semantics</title>

<para>
A class is defined much like a a function. The keyword <code>class</code>
is used after <code>def</code>. A class may have parameters (including
other classes), as in a function definition. The body of a class
may include function and class definitions. The name of every definition
in the body of a class is exported. 
<!--
(a later version of Orc implementation will allow the programmer to specify the names to be
exported through an export list).
-->
</para>

<para>
A class definition obeys all the rules of function definition
except:

<orderedlist>
<listitem>A class definition must include at least one
definition (which could be a class definition),</listitem>

<listitem>A class's goal expression must not publish,</listitem>

<listitem>Each function defined within a class publishes at most once.</listitem>
</orderedlist>
</para>

<para>
A class call creates and publishes a site (recall that the goal
expression of a class must not publish). Thus, 

<programlisting><![CDATA[
val st = Stack(5)
]]></programlisting>

instantiates site <code>st</code>. Multiple instances of a
class may be created by calling the class multiple times. The
functions (and classes) defined in the body of the class are
externally accessed as dot methods.
</para>
</section>

<section><title>Notes</title>

<itemizedlist>
<listitem><para>
Clausal definition: A class may be defined as a set of
  clauses, exactly as a function definition. In this case all clauses
  must define the same names to be exported.
</para></listitem>

<listitem><para>
Concurrent calls to methods: Methods of a class instance may
  be invoked concurrently, as in functions. It is the obligation of
  the programmer to ensure that concurrent calls do not
  interfere. Calling the methods of stack <code>st</code> concurrently may
  result in unintended outcomes. For example, in  
<programlisting><![CDATA[
  st.push(3) >> st.pop() >> Rwait(1000) >> st.pop()
| st.push(4) >> stop
]]></programlisting>
  the last <code>st.pop()</code> (in the first line) often does not succeed,
  because just one value was stored in the stack though there
  were two concurrent <code>st.push()</code> operations. 
</para></listitem>

<listitem><para>
Prune on class call: Like site calls, running class method invocations 
  are not terminated by the pruning combinator. In the following program,
  <code>x</code> is assigned value 3 because execution of <code>testprune().run()</code> never
  publishes. However,
  <code>testprune().run()</code> is treated as a site call which continues
  execution even after x is assigned a value. Eventually, the line
  <computeroutput>done</computeroutput> is printed.
<programlisting><![CDATA[
def class testprune() =
  def run() =  Rwait(1000) >> println("done") >> stop
  stop

  val x =  Rwait(50) >> 3 |  testprune().run()
  x
]]></programlisting>
</para></listitem>
</itemizedlist>
</section>

<section><title>Class Example</title>
	<para>
		The following shows the code for this sequence number generator in Orc: 
	</para>
	
	<programlisting><![CDATA[
-- the mutable integer defined with seed zero
val seq_num = Ref(0)
-- gen_seq will increase the seq_num and return the new value
def gen_seq() =
  seq_num := seq_num?+1 >> seq_num?
  
gen_seq() >s> println(s) >> gen_seq() >s> println(s) >> stop
]]></programlisting>
	
	<para>
		What is the problem with the above code? The first problem is that the seq_num is 
		exposed to all the expressions which come after it. This means that all those 
		expressions can possibly read and write the value of seq_num. This is not always 
		desirable and makes the reasoning about the program more difficult. The second issue 
		with this code is that it is not flexible enough. What if we want to have different 
		sequence number generator with a different initial seed? For example, we may want a 
		sequence number starting at 0 and another one starting at 1000.
	</para>

	<para>
		There is another issue associated with the above code from a concurrent programming 
		viewpoint. It is not thread safe. This means that if we make two parallel calls to 
		gen_seq(), we may get the same result. For example, the following piece of code: 
	</para>
	
		<programlisting><![CDATA[
gen_seq() | gen_seq()
]]></programlisting>
	
	<para> The above code can generate "1" as the publication for both expressions, and in most of the runs
		it will.  This is a famous phenomenon in parallel programming known as a race condition. 
		In fact, access to the shared variable seq_num is subject to race condition between 
		the two threads running the two calls to gen_seq(). To solve the race issue we need 
		to add a semaphore to the above code in order to regulate the access to the shared 
		variable, seq_num. Therefore, every call to gen_seq needs to acquire the semaphore in 
		order to update the variable and release the semaphore at the end. The new safe code 
		is as follows:  </para>
	
		<programlisting><![CDATA[
-- the mutable integer defined with seed zero
val seq_num = Ref(0)
-- a semaphore to regulate access to shared variable seq_num
val seq_num_sem = Semaphore(1)
-- gen_seq will increase the seq_num and return the new value
def gen_seq() =
  seq_num_sem.acquire() >> seq_num := seq_num?+1 >> 
  seq_num? >x> seq_num_sem.release() >> x
  
gen_seq() | gen_seq()
]]></programlisting>
	
	<para>
		The above code, besides the issue of encapsulation and the complexity of having more than 
		one sequence number generator, looks fine. However, there is a subtle problem with this code. 
		The problem is data corruption and invalid state which can be caused by abrupt termination 
		of the call to gen_seq(). Consider the following piece of code and corresponding execution order: 
	</para>
	
		<programlisting><![CDATA[
y <y< 1+1 | gen_seq()
		]]></programlisting>
	
		<programlisting><![CDATA[
1- 1+1
2- seq_num_sem.acquire()
3- y is bound to 2
4- terminate gen_seq()
		]]></programlisting>
	
	<para>
		As illustrated in the above execution sequence, the semaphore seq_num_sem got acquired but never 
		released because of abrupt termination. Therefore consecutive calls to gen_seq will never proceed 
		because they cannot acquire the semaphore. So, we need to somehow protect the execution of gen_seq. 
		Classes address all the above issues in a succinct way.
	</para>
	
	<para>
		The class solution to the sequence number generator is the following code:
	</para>
	
			<programlisting><![CDATA[
def class gen_seq(init) =
	-- the mutable integer defined with seed init
	val seq_num = Ref(init)
	-- the next function will increase the seq_num and return the new value
	def next() =
		seq_num := seq_num?+1 >> seq_num?
	signal

	val g = gen_seq(1000)

	g.next() >y> println(y) >> g.next() >y> println(y) >> stop
		]]></programlisting>
	
	<para>
		It is very easy to instantiate a new sequence number that starts with a different seed. We just need 
		to create a new instance of gen_seq with a different seed. The following code shows an example of creating 
		two sequence number generator with two different seeds. 
	</para>
	
		<programlisting><![CDATA[
val g0 = gen_seq(0)
val g1 = gen_seq(1000)

g0.next() >y> println(y) >> g1.next() >y> println(y) >> stop
		]]></programlisting>
	
	<para>
		Notice how easy it is to have a new sequence number generator. Comparatively, in a pure functional language where 
		we just have functions, we need to declare new declarations of seq_num to accomplish the job.
	</para>
	
	<para>
		Now, in order to solve the issue of thread safety, we want to add a semaphore to the class. Note that since 
		the execution of the class is protected we will not run into the problem of invalid state or data corruption 
		caused by abrupt termination. The following code shows the thread safe version of the sequence number generator. 
	</para>
	
	<programlisting><![CDATA[
def class gen_seq(init) =
	-- the mutable integer defined with seed init
	val seq_num = Ref(init)
	-- a semaphore to regulate access to shared variable seq_num
	val seq_num_sem = Semaphore(1)
	-- gen_seq will increase the seq_num and return the new value
	def next() =
		seq_num_sem.acquire() >> seq_num := seq_num?+1 >>
		seq_num? >x> seq_num_sem.release() >> x
	signal
		]]></programlisting>
	
</section>
	
<section><title>More Class Examples</title>

<para>
Here we show a few more examples of class usage.
</para>
	
<section><title>Active Classes</title></section>
	<para>
		Class is an active entity. Active objects, unlike passive ones, have 
		their own thread of control. They can initiate a computation without receiving 
		a method call (in procedural languages) or a message (in languages with message 
		passing model). Note that this definition of active objects subsumes reactive 
		objects and actors. We said that the execution of class is protected from the 
		rest of the program. Here we want to clarify what do we mean by creation of the 
		class and when the class actually exists.
	</para>
	
	<para>
		A class exists as soon as all the parameters and free variables in the class 
		are bound to their values. Thereafter, any method on the class can be called. This 
		means that the creation process would not wait for goal expression of the class to 
		finish. Therefore, the creation of the class would return immediately. But the goal 
		expression continues to execute. The goal expression will not publish anything. However, 
		it can have side effects. For example, it could print something on the screen or it 
		can initiate some other processes and send and receive data to and/or from buffers. 
	</para>
	
	<para>
		The following example explains the notion of activeness of classes. We want to design a 
		clock that ticks every n (user specified) milliseconds. We want to be able to get the 
		number of ticks passed since the process started. The following example shows a class 
		implementation of this clock.
	</para>
	
		<programlisting><![CDATA[
def class nclock(n) = -- tick every n milliseconds
	-- tick_cnt counts the number of ticks
	val tick_cnt = Ref(0)
	-- getTick returns the number of ticks passed so far
	def getTick() = tick_cnt?
	metronome(n) >> tick_cnt:=tick_cnt?+1

	val ticker = nclock(250)
	-- prints a mutiple of 4 every one second
	Rwait(1000) >> metronome(1000) >> ticker.getTick()
		]]></programlisting>
	
	<para>
		In this example, the class nclock has a tick counter tick_cnt that records the number of 
		ticks passed so far. The method getTick returns the number of ticks. The interesting point 
		about this class is its goal expression. The goal expression is a metronome that publish 
		a signal every n milliseconds. Each time a signal is issued it causes the tick_cnt to increase 
		by one. As can be seen, the goal expression would never stop. It keeps increasing the tick 
		counter for ever and a thread is always active in the nclock class instance. This program 
		keeps publishing the multiples of 4 starting from 4 upward. 
	</para>

<section><title>Multi-dimensional Matrix</title>

<para>
We declare a two dimensional matrix whose index ranges may span any
finite interval of integers. The same technique can be used to declare
any multi-dimensional matrix.
</para>

<programlisting><![CDATA[
def class Matrix((lo1, up1), (lo2, up2)) =
  val mat = Array((up1 - lo1 + 1) * (up2 - lo2 + 1))
  def access(i, j) = mat((i - lo1) * (up2 - lo2 + 1) + j)
  stop

----------------- Test
val A = Matrix((-2, 0), (-1, 3)).access
A(-1,2) := 5 >> A(-1, 2) := 3 >> A(-1, 2)?
]]></programlisting>

<para>
Note that we define matrix <code>A</code> to be the sole method, <code>access</code>, of the
class; this enables us to refer to matrix elements in the
traditional style.
</para>
</section>

<section><title>Create a new site</title>

<para>
We create a new site, bounded buffer, using <code>Buffer</code> and
<code>Semaphore</code> sites. The buffer stores the data items and the
semaphores are used to ensure proper blocking. Below, <code>n</code> is the
maximum buffer size, and <code>p</code> and <code>g</code> are semaphores whose values are the
number of empty and full positions, respectively. A <code>put</code> operation is
allowed only if <code>p > 0</code> and a <code>get</code> if <code>g > 0</code>.
</para>

<programlisting><![CDATA[
def class BBuffer(n) =
  val b = Buffer()
  val (p, g) = (Semaphore(n), Semaphore(0))
  def put(x) = p.acquire() >> b.put(x) >> g.release()
  def get() = g.acquire() >> b.get() >x> p.release() >> x
  stop
]]></programlisting>

<para>
Note that setting <code>n = 1</code> lets us define a 1-place buffer in which the
executions of 
<code>put</code> and <code>get</code> operations have to alternate.
</para>
</section>

<section><title>Extend functionality of existing site</title>

<para>
We add a <code>length</code> function to the <code>Buffer</code> site, that returns
its current length. 
</para>

<programlisting><![CDATA[
def class Channel() =
  val ch = Buffer()
  val chlen = Counter(0)

  def put(x) = ch.put(x) >> chlen.inc()
  def get() = ch.get() >x> chlen.dec() >> x
  def length() = chlen.value()
  stop
]]></programlisting>
</section>

<section><title>A Communication protocol; Rendezvous</title>

<para>
A set of senders and receivers communicate in the following manner. A
sender executes <code>send(v)</code> and a receiver <code>recv()</code>. The <code>send(v)</code> remains
blocked until some <code>recv()</code> operation is executed; similarly a
<code>recv()</code> is blocked until there is a corresponding <code>send(v)</code>. When both
<code>send(v)</code> and <code>recv()</code> operations are ready for execution,
the <code>recv()</code> operation receives data <code>v</code>, <code>send</code> receives a signal,
and both can then proceed.
</para>

<para>
We employ semaphore <code>s</code> on which the send operation blocks; <code>s</code> is released by
the receive operation. The sender then puts its data in a buffer and
the receiver reads from the buffer. 
</para>

<programlisting><![CDATA[
def class Rendezvous() =
  val (s,data) = (Semaphore(0), Buffer())
  def send(x) = s.acquire() >> data.put(x)
  def recv() = s.release() >> data.get()
  stop
]]></programlisting>

<para>
The following code fragment shows three threads that are forced to
execute their codes in a nearly sequential manner due to the restrictions
imposed by rendezvous.
</para>

<programlisting><![CDATA[
val group1 = Rendezvous()
val group2 = Rendezvous()

  group1.send(3)
| Rwait(1000) >> group2.recv()
| group2.send(5) >> group1.recv()
]]></programlisting>
</section>

<section><title>A class operating in real time</title>

<para>
We create a class to mimic a stopwatch. A stopwatch allows the
following operations: 
<itemizedlist>
<listitem><code>start()</code>: (re)starts the stopwatch and publishes a signal</listitem>
<listitem><code>halt()</code>: stops and publishes current value on the stopwatch</listitem>
</itemizedlist>
</para>

<para>
We implement an instance of a stopwatch by assigning a new clock to it
(created by calling site <code>Clock()</code> that returns a new clock
with value 0). Additionally, two mutable variables are used with
the following meaning.
<itemizedlist>
<listitem><code>timeshown</code>: clock value when the stopwatch was last stopped,</listitem>
<listitem><code>laststart</code>: clock value when the stopwatch was last started.</listitem>
</itemizedlist>
Initially, both variable values are 0.
</para>

<programlisting><![CDATA[
def class Stopwatch() =
  val clk = Clock()
  val (timeshown, laststart) = (Ref(0), Ref(0))

  def start() = laststart := clk()

  def halt() = timeshown := timeshown? + (clk() - laststart?) >> timeshown?
  stop
]]></programlisting>

<para>
A useable implementation of stopwatch requires a more general
interface. It should allow <code>start</code> operation in the state where
the stopwatch is already running, and <code>halt</code> in a state where the
stopwatch is already halted. Additionally, an operation to determine
the staus of the stopwatch (running or not) should be provided. Such
an implementation is given for the library site, <code>Stopwatch</code>; see
 the <code>Stopwatch</code> site in <xref linkend="appendix.library"/>.  
</para>
</section>

</section>

</section>


</section>


</chapter>
