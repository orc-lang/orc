<html><head><META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>3.2.&nbsp; class Sites</title><meta content="DocBook XSL Stylesheets V1.74.0" name="generator"><link rel="home" href="index.html" title="Orc User Guide v2.0.0"><link rel="up" href="ch03.html" title="Chapter&nbsp;3.&nbsp;Accessing and Creating External Services"><link rel="prev" href="ch03.html" title="Chapter&nbsp;3.&nbsp;Accessing and Creating External Services"><link rel="next" href="ch03s03.html" title="3.3.&nbsp;Cooperative Scheduling and Concurrency"><link href="/orchard/orc.css" type="text/css" rel="stylesheet"><link href="style.css" type="text/css" rel="stylesheet"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table summary="Navigation header" width="100%"><tr><th align="center" colspan="3">3.2.&nbsp;

                class Sites</th></tr><tr><td align="left" width="20%"><a accesskey="p" href="ch03.html">Prev</a>&nbsp;</td><th align="center" width="60%">Chapter&nbsp;3.&nbsp;Accessing and Creating External Services</th><td align="right" width="20%">&nbsp;<a accesskey="n" href="ch03s03.html">Next</a></td></tr></table><hr></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="section.services.java"></a>3.2.&nbsp;

                <code class="code"><span class="hl-keyword">class</span></code> Sites</h2></div></div></div><p>
Scala and Java classes can be imported into Orc as sites using the <a class="link" href="ch01s04.html#section.orc.class" title="1.4.5.1.&nbsp; class declaration">

                    <code class="code"><span class="hl-keyword">class</span></code> declaration</a>.
Imported classes must be in the classpath of the JVM running the Orc
interpreter.  The following sections describe in detail how such imported
classes behave in Orc programs.
</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="section.services.java.dot"></a>3.2.1.&nbsp;Dot Operator</h3></div></div></div><p>
<code class="code"><span class="hl-variable">x</span>.<span class="hl-variable">member</span></code>, where <code class="code"><span class="hl-variable">x</span></code> evaluates to a Scala/Java class or object, 
is evaluated as follows:
<div class="itemizedlist"><ul type="disc"><li>If <code class="code"><span class="hl-variable">x</span></code> has one or more methods named <code class="code"><span class="hl-variable">member</span></code>,
a "method handle" site is returned which may be called like any other Orc site.
When a method handle is actually called with arguments, the appropriate Scala/Java
method is selected and called depending on the number and type of arguments, as

described in <a class="link" href="ch03s02.html#section.services.java.method" title="3.2.4.&nbsp;Method Resolution">Method Resolution</a>
below.</li><li>Otherwise, if <code class="code"><span class="hl-variable">x</span></code> has a field named <code class="code"><span class="hl-variable">member</span></code>,
the object's field is returned, encapsulated in a <a class="link" href="apbs03.html#orc.lib.state.Ref">
                                <code class="code"><span class="hl-variable">Ref</span></code> object</a>. The
<code class="code"><span class="hl-variable">Ref</span></code> object has <code class="code"><span class="hl-variable">read</span></code> and <code class="code"><span class="hl-variable">write</span></code> methods
which are used to get and set the value of the field.</li></ul></div>
</p><p>
Note that no distinction is made between static and non-static members; it is
an error to reference a non-static member through a class, but this does not
change how members are resolved.  Note also that if a field shares a name with
one or more methods, there is no way to access the field directly.
</p><p>
The following (rather useless) example illustrates how the dot operator can be
used to access both static and non-static methods and fields:
<pre class="programlisting">
<span class="hl-comment">{- bind Integer to a Java class -}</span>
<span class="hl-keyword">class</span> <span class="hl-variable">Integer</span> = <span class="hl-variable">java</span>.<span class="hl-variable">lang</span>.<span class="hl-variable">Integer</span>

<span class="hl-comment">{- call a static method -}</span>
<span class="hl-keyword">val</span> <span class="hl-variable">i</span> = <span class="hl-variable">Integer</span>.<span class="hl-site">decode</span>(<span class="hl-literal">"5"</span>)
<span class="hl-comment">{- read a field -}</span>
<span class="hl-keyword">val</span> <span class="hl-variable">m</span> = <span class="hl-variable">Integer</span>.<span class="hl-variable">MIN_VALUE</span>.<span class="hl-site">read</span>()
<span class="hl-comment">{- write a field -}</span>
<span class="hl-variable">Integer</span>.<span class="hl-variable">MIN_VALUE</span>.<span class="hl-site">write</span>(<span class="hl-literal">5</span>) <span class="hl-combinator">&gt;</span><span class="hl-combinator">&gt;</span>
<span class="hl-comment">{- call a non-static method -}</span>
<span class="hl-variable">i</span>.<span class="hl-site">toString</span>()
</pre>
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N1175A"></a>3.2.2.&nbsp;Direct Calls</h3></div></div></div><p>
When <code class="code"><span class="hl-variable">x</span></code> evaluates to a Scala/Java object (but not a Scala/Java class), the syntax
<code class="code"><span class="hl-site">x</span>(...)</code> is equivalent to <code class="code"><span class="hl-variable">x</span>.<span class="hl-site">apply</span>(...)</code>.
</p><p>
When <code class="code"><span class="hl-variable">x</span></code> evaluates to a Scala/Java class, the syntax <code class="code"><span class="hl-site">x</span>(...)</code>
calls the class's constructor.  In case of overloaded constructors, the
appropriate constructor is chosen based on the number and types of arguments as
described in <a class="link" href="ch03s02.html#section.services.java.method" title="3.2.4.&nbsp;Method Resolution">Method Resolution</a>.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N11774"></a>3.2.3.&nbsp;Pattern Matching</h3></div></div></div><p>
If <code class="code"><span class="hl-variable">C</span></code> is bound to a Scala/Java class, it can be used as a pattern.
A pattern <code class="code"><span class="hl-site">C</span>(<span class="hl-variable">x</span>)</code> matches any Scala/Java object of that class or
any of its subclasses. The variable <code class="code"><span class="hl-variable">x</span></code> is simply bound
to the object again; thus the matcher is just a partial identity function.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="section.services.java.method"></a>3.2.4.&nbsp;Method Resolution</h3></div></div></div><p>
When a method handle is called, the actual Scala/Java method called is chosen based
on the runtime types of the arguments, as follows:
<div class="orderedlist"><ol type="1"><li>If only one method has the appropriate number of arguments, that method is called.</li><li>Otherwise, each method taking the appropriate number of arguments is
	tested for type compatibility as follows, and the first matching method
	is called.
	<div class="orderedlist"><ol type="a"><li>Every argument is compared to the corresponding formal
		parameter type as follows. All arguments must match for the
		method to match.
		<div class="orderedlist"><ol type="i"><li>If the argument is null, then the argument matches</li><li>If the formal parameter type is primitive (int, char,
			float, ...) and the argument is an instance of a
			wrapper class, then the argument is unboxed (unwrapped)
			and coerced to the type of the formal parameter
			according to Java's standard rules for implicit
			widening coercions.</li><li>If the formal parameter type is a primitive numeric type
			and the argument is an instance of <code class="code">BigDecimal</code>,
			the argument is implicitly narrowed to the formal parameter type.</li><li>If the formal parameter type is a primitive integral type
			and the argument is an instance of <code class="code">BigInt</code>,
			the argument is implicitly narrowed to the formal parameter type.</li><li>Otherwise, the argument must be a subtype of the formal parameter type.</li></ol></div></li></ol></div></li></ol></div>
</p><p>
The reason for the unusual implicit narrowing of <code class="code">BigDecimal</code> and
<code class="code">BigInt</code> is that Orc numeric literals have these types, and it
would be awkward to have to perform an explicit conversion every time such a
value is passed to a Java method expecting a primitive.
</p><p>
Currently we do not implement specificity rules for choosing the best matching
method; the first matching method (according to some unspecified order) is
chosen.  Note also that we do not support varargs methods explicitly, but
instead varargs may be passed as an array of the appropriate type.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N117B0"></a>3.2.5.&nbsp;Orc values in Scala</h3></div></div></div><p>
Orc values are implemented by Scala objects, so in general any Orc value may be
passed to a site implemented in Scala.  Standard Orc values have the following
Scala types:
</p><div class="variablelist"><dl><dt><span class="term">string</span></dt><dd><code class="code">java.lang.String</code></dd><dt><span class="term">boolean</span></dt><dd><code class="code">java.lang.Boolean</code></dd><dt><span class="term">number</span></dt><dd><code class="code">scala.math.BigDecimal and scala.math.BigInt</code></dd><dt><span class="term">tuple</span></dt><dd><code class="code">orc.values.OrcTuple</code></dd><dt><span class="term">list</span></dt><dd><code class="code">scala.collection.immutable.List</code></dd><dt><span class="term">function</span></dt><dd><code class="code">orc.run.Closure</code><p>Currently it is not possible to call Orc functions from Java code.</p></dd><dt><span class="term">site</span></dt><dd><code class="code">orc.value.sites.Sites</code><p>Currently it is not possible to directly call Orc sites from Java
code.  However if you are implementing a site yourself, you may provide methods
which can be called from Scala/Java code to invoke the behavior of the site.</p></dd></dl></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N117EC"></a>3.2.6.&nbsp;Scala Values in Orc</h3></div></div></div><p>
Scala objects may be used directly as values anywhere in an Orc program.
Primitive Scala values cannot be used directly in an Orc program, but are
automatically boxed (and unboxed) as necessary.
</p><p>
When both arguments of an arithmetic or comparison operator are Java or Scala numeric
types, the arguments are implicitly coerced to the widest of the two argument
types.  "Widest" is defined by the following relation, where "&gt;" means "is
wider than": BigDecimal &gt; Double &gt; Float &gt; BigInt &gt; Long &gt; Integer &gt; Short
&gt; Byte
</p></div></div><script type="text/javascript" src="/orchard/orc.js"></script><div class="navfooter"><hr><table summary="Navigation footer" width="100%"><tr><td align="left" width="40%"><a accesskey="p" href="ch03.html">Prev</a>&nbsp;</td><td align="center" width="20%"><a accesskey="u" href="ch03.html">Up</a></td><td align="right" width="40%">&nbsp;<a accesskey="n" href="ch03s03.html">Next</a></td></tr><tr><td valign="top" align="left" width="40%">Chapter&nbsp;3.&nbsp;Accessing and Creating External Services&nbsp;</td><td align="center" width="20%"><a accesskey="h" href="index.html">Home</a></td><td valign="top" align="right" width="40%">&nbsp;3.3.&nbsp;Cooperative Scheduling and Concurrency</td></tr></table></div></body></html>