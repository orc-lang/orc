//
// MakeDoc.java -- Java class MakeDoc
// Project OrcJava
//
// $Id$
//
// Copyright (c) 2009 The University of Texas at Austin. All rights reserved.
//
// Use and redistribution of this file is governed by the license terms in
// the LICENSE file found in the project's top-level directory and also found at
// URL: http://orc.csres.utexas.edu/license.shtml .
//

package orc.doc;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.text.DateFormat;
import java.util.Date;
import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;

import xtc.parser.ParseException;
import xtc.parser.Result;

/**
 * @author quark
 */
public class MakeDoc {
	private static class DocNodes {
		public String file;
		public List<DocNode> nodes;

		public DocNodes(final String file, final List<DocNode> nodes) {
			this.file = file;
			this.nodes = nodes;
		}
	}

	public static void main(final String[] args) throws ParseException, IOException {
		final List<DocNodes> files = new LinkedList<DocNodes>();
		for (final String file : args) {
			files.add(new DocNodes(file, parseFile(file)));
		}
		System.out.println("<?xml version=\"1.0\"?>");
		System.out.print("<!-- Generated by orc.doc.MakeDoc from");
		for (final String file : args) {
			System.out.print(" " + file);
		}
		System.out.println(" on " + DateFormat.getDateTimeInstance().format(new Date()) + " -->");
		System.out.println("<section><title>Reference</title>");
		for (final DocNodes file : files) {
			System.out.print("<section><title>");
			System.out.print(escapeXML(file.file));
			if (!file.nodes.isEmpty()) {
				final DocNode first = file.nodes.get(0);
				if (first instanceof DocParagraph) {
					System.out.print(": ");
					System.out.print(firstSentence(((DocParagraph) first).body.trim()));
				}
			}
			System.out.println("</title>");
			int depth = 0;
			for (final DocNode doc : file.nodes) {
				if (doc instanceof DocParagraph) {
					final String body = ((DocParagraph) doc).body.trim();
					if (!body.equals("")) {
						System.out.print("<para>");
						System.out.print(body);
						System.out.println("</para>");
					}
				} else if (doc instanceof DocTag) {
					System.out.print(((DocTag) doc).value);
				} else if (doc instanceof DocType) {
					final DocType type = (DocType) doc;
					if (type.depth > depth) {
						System.out.println("<variablelist>");
						System.out.println("<?dbfo list-presentation=\"list\"?>");
						System.out.println("<?dbhtml list-presentation=\"table\"?>");
						depth = type.depth;
					} else {
						while (type.depth < depth) {
							System.out.println("</listitem></varlistentry></variablelist>");
							--depth;
						}
						if (type.depth == depth) {
							System.out.println("</listitem></varlistentry>");
						}
						depth = type.depth;
					}
					System.out.print("<varlistentry><term>");
					System.out.print("<code>" + escapeXML(extractName(type.type)) + "</code>");
					System.out.print("</term><listitem>");
					System.out.print("<para>");
					System.out.print("<code>" + escapeXML(type.type) + "</code>");
					System.out.println("</para>");
				}
			}
			while (0 < depth) {
				System.out.println("</listitem></varlistentry></variablelist>");
				--depth;
			}
			System.out.println("</section>");
		}
		System.out.println("</section>");
	}

	public static String extractName(final String type) {
		// extract everything between the declaration keyword
		// and the argument list
		return type.replaceAll("[a-z]+\\s+(.[^(]+).*", "$1")
		// drop type parameters
				.replaceFirst("\\[[^\\]]+\\]", "")
				// drop the method receiver type
				.replaceFirst("^[^.]+\\.", "");
	}

	public static String firstSentence(final String para) {
		final String[] parts = para.split("(?<=[.?!])\\s+", 2);
		return parts[0];
	}

	public static List<DocNode> parseFile(final String file) throws ParseException, IOException {
		final DocParser parser = new DocParser(new InputStreamReader(new FileInputStream(file)), file);
		final Result result = parser.pContent(0);
		final List<DocNode> nodes = (List<DocNode>) parser.value(result);

		// fill in values of @implementation tags
		DocCode lastCode = new DocCode("");
		final ListIterator<DocNode> it = nodes.listIterator(nodes.size());
		while (it.hasPrevious()) {
			final DocNode node = it.previous();
			if (node instanceof DocCode) {
				lastCode = (DocCode) node;
			} else if (node instanceof DocTag) {
				final DocTag tag = (DocTag) node;
				if (tag.name.equals("implementation")) {
					tag.value = "<formalpara><title>Implementation</title>" + "<programlisting>" + escapeXML(lastCode.text.trim()) + "</programlisting>" + "</formalpara>";
				}
			}
		}
		return nodes;
	}

	public static String escapeXML(final String text) {
		final StringBuilder sb = new StringBuilder();
		final int len = text.length();
		for (int i = 0; i < len; i++) {
			final char c = text.charAt(i);
			switch (c) {
			case 34:
				sb.append("&quot;");
				break;
			case 38:
				sb.append("&amp;");
				break;
			case 39:
				sb.append("&apos;");
				break;
			case 60:
				sb.append("&lt;");
				break;
			case 62:
				sb.append("&gt;");
				break;
			default:
				if (c > 0x7F) {
					sb.append("&#");
					sb.append(Integer.toString(c, 10));
					sb.append(';');
				} else {
					sb.append(c);
				}
			}
		}
		return sb.toString();
	}
}
